<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Our 1 Year</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#05060a; }
    #app { position:fixed; inset:0; }

    #hud{
      position: fixed;
      left: 12px; top: 12px;
      color: rgba(255,255,255,0.9);
      font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      z-index: 5;
      user-select:none;
      background: rgba(0,0,0,0.35);
      padding: 10px 12px;
      border-radius: 12px;
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.12);
      max-width: 380px;
    }
    #hint { opacity:0.85; margin-top:6px; font-size:13px; }

    /* Center memory popup */
    #panel{
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: min(520px, calc(100vw - 28px));
      max-height: min(60vh, 520px);
      overflow:auto;
      z-index: 6;
      background: rgba(10,12,18,0.86);
      color: rgba(255,255,255,0.92);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 18px;
      padding: 14px 14px 12px;
      backdrop-filter: blur(10px);
      display:none;
    }
    #panel h2 { margin: 2px 0 8px; font-size: 18px; }
    #panel p { margin: 0 0 10px; font-size: 14px; opacity:0.92; }
    #closeBtn{
      position:absolute;
      top:10px; right:10px;
      background: rgba(255,255,255,0.12);
      color:#fff; border:1px solid rgba(255,255,255,0.14);
      border-radius: 10px; padding: 6px 10px;
      cursor:pointer;
    }

    #footer{
      position: fixed;
      left: 12px; bottom: 12px;
      z-index: 5;
      color: rgba(255,255,255,0.65);
      font: 12px system-ui;
      background: rgba(0,0,0,0.25);
      padding: 6px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      user-select:none;
    }
    code { color: #d7e3ff; }
  </style>
</head>
<body>
  <div id="app"></div>

  <div id="hud">
    <div><strong>Controls:</strong> WASD move Â· Shift run Â· Space jump Â· Mouse drag rotate</div>
    <div id="hint">Tip: edit <code>MEMORIES</code> in the code.</div>
  </div>

  <div id="panel">
    <button id="closeBtn">Close</button>
    <h2 id="panelTitle"></h2>
    <p id="panelText"></p>
  </div>

  <div id="footer">Built for us ðŸ’™</div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

<script type="module">
  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { FBXLoader } from "three/addons/loaders/FBXLoader.js";

  // ====== EDIT THESE ======
  const AVATAR_URL = "https://models.readyplayer.me/695c48e31c1817592c4ec48b.glb";
  const ANIMS = {
    Idle: "assets/anim/Idle.fbx",
    Walk: "assets/anim/Walk.fbx",
    Run:  "assets/anim/Run.fbx",
    Jump: "assets/anim/Jump.fbx",
  };

  const MEMORIES = [
    { id:"first-meet", title:"How we met", text:"Write a short story here.", pos:new THREE.Vector3(-6,0,-4) },
    { id:"first-date", title:"First date", text:"Where did you go? One detail you remember.", pos:new THREE.Vector3(6,0,-2) },
    { id:"moment", title:"The moment I knew", text:"One moment that made it clear sheâ€™s your person.", pos:new THREE.Vector3(-2,0,7) },
    { id:"future", title:"Whatâ€™s next", text:"Something youâ€™re excited to do together this year.", pos:new THREE.Vector3(7,0,7) },
  ];

  // ====== Tuning ======
  const WALK_SPEED = 2.6;   // slower
  const RUN_SPEED  = 8;   // comfy run
  const AIR_CONTROL = 0.65; // you can still steer a bit in air

  const GRAVITY = -18.0;    // units/s^2
  const JUMP_VEL = 6.4;     // units/s

  const CAM_HEIGHT = 1.85;
  const CAM_DIST   = 3.8;   // close behind
  const CAM_SIDE   = 0.0;
  const CAM_LERP   = 0.16;  // smoothing
  const LOOK_HEIGHT = 1.45;

  // If Run clip maps fewer than this number of tracks, itâ€™s basically broken -> fallback to Walk.
  const MIN_TRACKS_FOR_RUN = 40;

  // ====== Small utilities ======
  function normalizeKey(name) {
    return String(name || "")
      .replace(/^Armature\|/i, "")
      .replace(/^mixamorig/i, "")
      .replace(/[^a-z0-9]/gi, "")
      .toLowerCase();
  }

  function buildBoneKeyToNameMap(root) {
    const map = new Map();
    root.traverse((o) => {
      if (!o.isBone) return;
      const key = normalizeKey(o.name);
      if (key && !map.has(key)) map.set(key, o.name);
    });
    return map;
  }

  function stripRootTranslation(clip) {
    // Remove ALL position tracks so animations are fully "in-place" (we move manually).
    const tracks = clip.tracks.filter((t) => !t.name.toLowerCase().endsWith(".position"));
    return new THREE.AnimationClip(clip.name, clip.duration, tracks);
  }

  function remapClipToAvatarBones(clip, avatarRoot, debugLabel) {
    const boneMap = buildBoneKeyToNameMap(avatarRoot);
    const outTracks = [];

    let mapped = 0;

    for (const tr of clip.tracks) {
      const parts = tr.name.split(".");
      if (parts.length < 2) continue;

      const srcNode = parts[0];
      const prop = parts.slice(1).join(".");
      const key = normalizeKey(srcNode);
      const dstBoneName = boneMap.get(key);
      if (!dstBoneName) continue;

      const dstTrackName = `${dstBoneName}.${prop}`;
      const times = tr.times.slice();
      const values = tr.values.slice();

      if (tr.ValueTypeName === "quaternion") {
        outTracks.push(new THREE.QuaternionKeyframeTrack(dstTrackName, times, values));
        mapped++;
      } else if (tr.ValueTypeName === "vector") {
        outTracks.push(new THREE.VectorKeyframeTrack(dstTrackName, times, values));
        mapped++;
      }
    }

    const out = new THREE.AnimationClip(clip.name || debugLabel, clip.duration, outTracks);
    out.userData = { mappedTracks: mapped, label: debugLabel };
    return out;
  }

  function forceMeshVisible(root) {
    root.traverse((o) => {
      if (!o.isMesh) return;
      o.frustumCulled = false;
      o.visible = true;
      o.castShadow = true;
      o.receiveShadow = true;

      const mats = Array.isArray(o.material) ? o.material : [o.material];
      for (const m of mats) {
        if (!m) continue;
        m.depthWrite = true;
        m.depthTest = true;
        m.needsUpdate = true;
      }
    });
  }

  // ====== Scene setup ======
  const app = document.getElementById("app");
  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x05060a, 12, 70);

  const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 250);
  camera.position.set(0, 4, 6);

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setClearColor(0x05060a, 1);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  app.appendChild(renderer.domElement);

  // Lights
  scene.add(new THREE.HemisphereLight(0xaecbff, 0x1a1d2b, 0.95));
  const dir = new THREE.DirectionalLight(0xffffff, 1.15);
  dir.position.set(12, 18, 10);
  dir.castShadow = true;
  dir.shadow.mapSize.set(1024, 1024);
  dir.shadow.camera.left = -30;
  dir.shadow.camera.right = 30;
  dir.shadow.camera.top = 30;
  dir.shadow.camera.bottom = -30;
  scene.add(dir);

  // Procedural grass texture
  function makeGrassTexture() {
    const c = document.createElement("canvas");
    c.width = 256; c.height = 256;
    const g = c.getContext("2d");

    g.fillStyle = "#0b1a10";
    g.fillRect(0,0,c.width,c.height);

    for (let i=0;i<5000;i++){
      const x = (Math.random()*c.width)|0;
      const y = (Math.random()*c.height)|0;
      const v = 35 + (Math.random()*60)|0;
      g.fillStyle = `rgb(${8},${v},${20})`;
      g.fillRect(x,y,1,1);
    }

    for (let i=0;i<200;i++){
      const x = Math.random()*c.width;
      const y = Math.random()*c.height;
      const r = 2 + Math.random()*6;
      g.globalAlpha = 0.08;
      g.fillStyle = "#89ffb0";
      g.beginPath();
      g.arc(x,y,r,0,Math.PI*2);
      g.fill();
    }
    g.globalAlpha = 1;

    const tex = new THREE.CanvasTexture(c);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(8,8);
    tex.anisotropy = Math.min(renderer.capabilities.getMaxAnisotropy(), 8);
    tex.needsUpdate = true;
    return tex;
  }

  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(60, 60),
    new THREE.MeshStandardMaterial({
      map: makeGrassTexture(),
      color: 0xffffff,
      roughness: 0.95,
      metalness: 0
    })
  );
  ground.rotation.x = -Math.PI/2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Walls / boundaries
  const wallMat = new THREE.MeshStandardMaterial({ color: 0x111634, roughness: 0.9 });
  function wall(w,h,d,x,y,z){
    const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), wallMat);
    m.position.set(x,y,z);
    m.castShadow = true; m.receiveShadow = true;
    scene.add(m);
    return m;
  }
  wall(40, 2.5, 0.8, 0, 1.25, -20);
  wall(40, 2.5, 0.8, 0, 1.25, 20);
  wall(0.8, 2.5, 40, -20, 1.25, 0);
  wall(0.8, 2.5, 40,  20, 1.25, 0);

  // Props
  const propMat = new THREE.MeshStandardMaterial({ color: 0x1a2250, roughness: 0.8 });
  function pillar(x,z){
    const p = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.8,3.2,18), propMat);
    p.position.set(x,1.6,z);
    p.castShadow = true; p.receiveShadow = true;
    scene.add(p);
  }
  pillar(-10,10); pillar(10,-10); pillar(0,0);

  // Player container
  const player = new THREE.Group();
  player.position.set(0,0,8);
  scene.add(player);

  // ====== Orbit camera locked to player ======
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.enablePan = false;
  
  // zoom with wheel
  controls.enableZoom = true;
  controls.zoomSpeed = 0.9;
  
  // keep it close + consistent
  controls.minDistance = 2.6;
  controls.maxDistance = 7.0;
  
  controls.minPolarAngle = 0.15;
  controls.maxPolarAngle = Math.PI * 0.48;
  
  controls.rotateSpeed = 0.6;
  
  // initial target
  controls.target.copy(player.position).add(new THREE.Vector3(0, LOOK_HEIGHT, 0));
  controls.update();
  
  // ====== Memory spots ======
  const spots = [];
  const spotGeo = new THREE.TorusGeometry(1.0, 0.12, 16, 50);
  const glowMat = new THREE.MeshStandardMaterial({
    color: 0x7da6ff,
    emissive: 0x3b66ff,
    emissiveIntensity: 1.6,
    roughness: 0.2,
    metalness: 0.25
  });

  for (const mem of MEMORIES) {
    const ring = new THREE.Mesh(spotGeo, glowMat.clone());
    ring.rotation.x = Math.PI / 2;
    ring.position.copy(mem.pos);
    ring.position.y = 0.12;
    ring.receiveShadow = true;
    scene.add(ring);

    const marker = new THREE.Mesh(
      new THREE.SphereGeometry(0.18, 18, 18),
      new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x7da6ff, emissiveIntensity: 1.2 })
    );
    marker.position.copy(mem.pos);
    marker.position.y = 1.35;
    marker.castShadow = true;
    scene.add(marker);

    spots.push({ mem, ring, marker });
  }

  // UI
  const panel = document.getElementById("panel");
  const panelTitle = document.getElementById("panelTitle");
  const panelText = document.getElementById("panelText");
  document.getElementById("closeBtn").onclick = () => { panel.style.display = "none"; activeSpotId = null; };

  let activeSpotId = null;
  function openMemory(mem){
    activeSpotId = mem.id;
    panelTitle.textContent = mem.title;
    panelText.textContent = mem.text;
    panel.style.display = "block";
  }

  // ====== Avatar + Animations ======
  const gltfLoader = new GLTFLoader();
  const fbxLoader  = new FBXLoader();

  let avatarRoot = null;
  let mixer = null;
  const actions = {};
  let currentAction = null;

  function playAction(name, fade=0.14){
    const next = actions[name];
    if (!next) return;
    if (currentAction === next) return;

    if (currentAction) currentAction.fadeOut(fade);
    currentAction = next;
    currentAction.reset().fadeIn(fade).play();
  }

  function loadFBX(url){
    return new Promise((resolve, reject) => {
      fbxLoader.load(url, (fbx) => {
        const clip = fbx.animations && fbx.animations[0];
        if (!clip) return reject(new Error("No animation in " + url));
        resolve(clip);
      }, undefined, reject);
    });
  }

  async function setupAvatarAndAnims(){
    const gltf = await new Promise((resolve, reject) => {
      gltfLoader.load(AVATAR_URL, resolve, undefined, reject);
    });

    avatarRoot = gltf.scene;
    forceMeshVisible(avatarRoot);

    avatarRoot.position.set(0,0,0);
    avatarRoot.rotation.set(0,0,0);
    avatarRoot.scale.set(1,1,1);
    player.add(avatarRoot);

    mixer = new THREE.AnimationMixer(avatarRoot);

    const [idleRaw, walkRaw, runRaw, jumpRaw] = await Promise.all([
      loadFBX(ANIMS.Idle),
      loadFBX(ANIMS.Walk),
      loadFBX(ANIMS.Run),
      loadFBX(ANIMS.Jump),
    ]);

    const idle = remapClipToAvatarBones(stripRootTranslation(idleRaw), avatarRoot, "Idle");
    const walk = remapClipToAvatarBones(stripRootTranslation(walkRaw), avatarRoot, "Walk");
    const run  = remapClipToAvatarBones(stripRootTranslation(runRaw),  avatarRoot, "Run");
    const jump = remapClipToAvatarBones(stripRootTranslation(jumpRaw), avatarRoot, "Jump");

    actions.Idle = mixer.clipAction(idle);
    actions.Walk = mixer.clipAction(walk);
    actions.Jump = mixer.clipAction(jump);

    // --- Run: protect against T-pose ---
    if ((run.tracks?.length || 0) < MIN_TRACKS_FOR_RUN) {
      // fallback: reuse walk action as "run" with faster timeScale
      console.warn("Run clip mapped too few tracks -> falling back to Walk for Run.");
      actions.Run = mixer.clipAction(walk);
      actions.Run.setEffectiveTimeScale(1.35);
    } else {
      actions.Run = mixer.clipAction(run);
      actions.Run.setEffectiveTimeScale(1.08);
    }

    actions.Walk.setEffectiveTimeScale(1.0);
    actions.Idle.setEffectiveTimeScale(1.0);

    actions.Jump.loop = THREE.LoopOnce;
    actions.Jump.clampWhenFinished = true;

    // When jump animation finishes, we can exit jump state IF we already landed.
    if (mixer) {
      mixer.addEventListener("finished", (e) => {
        if (e.action === actions.Jump) jumpAnimDone = true;
      });
    }

    console.log("Animations ready:", Object.keys(actions));
    playAction("Idle", 0.0);
  }

  setupAvatarAndAnims().catch((e) => console.error("Avatar/anims failed:", e));

  // ====== Movement + Jump physics ======
  const keys = new Set();
  window.addEventListener("keydown", (e) => keys.add(e.key.toLowerCase()));
  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

  const clock = new THREE.Clock();
  const tmpVec = new THREE.Vector3();

  function clampToMap(pos) {
    pos.x = Math.max(-18.5, Math.min(18.5, pos.x));
    pos.z = Math.max(-18.5, Math.min(18.5, pos.z));
  }

  let isJumping = false;
  let yVel = 0;
  let jumpAnimDone = false;

  function startJump() {
    if (isJumping) return;
    isJumping = true;
    jumpAnimDone = false;
    yVel = JUMP_VEL;
    playAction("Jump", 0.06);
  }

  function updatePlayer(dt){
    // Jump input
    if ((keys.has(" ") || keys.has("spacebar")) && !isJumping) {
      startJump();
    }

    const isRunning = keys.has("shift");
    const speed = isRunning ? RUN_SPEED : WALK_SPEED;

    let forward = 0, right = 0;
    if (keys.has("w")) forward += 1;
    if (keys.has("s")) forward -= 1;
    if (keys.has("d")) right += 1;
    if (keys.has("a")) right -= 1;

    // Basis from camera direction (orbit-friendly)
    const dirF = new THREE.Vector3();
    camera.getWorldDirection(dirF);
    dirF.y = 0;
    dirF.normalize();
    
    const dirR = new THREE.Vector3().crossVectors(dirF, new THREE.Vector3(0,1,0)).normalize();

    tmpVec.set(0,0,0);
    tmpVec.addScaledVector(dirF, forward);
    tmpVec.addScaledVector(dirR, right);

    const isMoving = tmpVec.lengthSq() > 0;

    // Rotate character toward movement direction
    if (isMoving) {
      const mv = tmpVec.clone().normalize();
      const targetYaw = Math.atan2(mv.x, mv.z);
    
      let d = targetYaw - player.rotation.y;
      d = Math.atan2(Math.sin(d), Math.cos(d));
      player.rotation.y += d * Math.min(1, dt * 10);
    }

    // Apply horizontal movement
    if (isMoving) {
      const control = isJumping ? AIR_CONTROL : 1.0;
      tmpVec.normalize().multiplyScalar(speed * control * dt);
      player.position.add(tmpVec);
      clampToMap(player.position);
    }

    // Apply jump physics
    if (isJumping) {
      yVel += GRAVITY * dt;
      player.position.y += yVel * dt;

      // Land
      if (player.position.y <= 0) {
        player.position.y = 0;
        yVel = 0;

        // Only exit jump when animation ended OR weâ€™ve been in jump long enough.
        // (If your Jump FBX is short, this avoids snapping too soon.)
        if (jumpAnimDone) {
          isJumping = false;
        }
      }
    }

    // Animation switching
    if (actions.Idle) {
      if (isJumping) {
        playAction("Jump", 0.05);
      } else if (isMoving && isRunning) {
        playAction("Run", 0.12);
      } else if (isMoving) {
        playAction("Walk", 0.14);
      } else {
        playAction("Idle", 0.18);
      }
    }
  }

  function updateCamera(dt){
    const target = player.position.clone();
    target.y += LOOK_HEIGHT;
  
    // smooth follow target (no camera drift)
    controls.target.lerp(target, 1 - Math.pow(0.001, dt));
    controls.update();
  }

  function checkMemoryTriggers(){
    let closest = null;
    let closestDist = Infinity;

    for (const s of spots) {
      const d = player.position.distanceTo(s.mem.pos);
      if (d < closestDist) { closestDist = d; closest = s; }
    }

    if (closest && closestDist <= 2.1) {
      if (activeSpotId !== closest.mem.id) openMemory(closest.mem);
    }
  }

  function animate(){
    requestAnimationFrame(animate);
    const dt = Math.min(clock.getDelta(), 0.033);

    updatePlayer(dt);
    updateCamera(dt);

    const t = clock.elapsedTime;
    for (const s of spots) {
      s.ring.rotation.z = t * 0.7;
      s.marker.position.y = 1.35 + Math.sin(t * 2.2 + s.mem.pos.x) * 0.08;
    }

    if (mixer) mixer.update(dt);

    checkMemoryTriggers();
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
