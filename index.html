<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Our 1 Year</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#05060a; }
    #app { position:fixed; inset:0; }

    #hud{
      position: fixed;
      left: 12px; top: 12px;
      color: rgba(255,255,255,0.9);
      font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      z-index: 5;
      user-select:none;
      background: rgba(0,0,0,0.35);
      padding: 10px 12px;
      border-radius: 12px;
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.12);
      max-width: 360px;
    }
    #hint { opacity:0.85; margin-top:6px; font-size:13px; }

    #panel{
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: min(520px, calc(100vw - 28px));
      max-height: min(60vh, 520px);
      overflow:auto;
      z-index: 6;
      background: rgba(10,12,18,0.82);
      color: rgba(255,255,255,0.92);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 18px;
      padding: 14px 14px 12px;
      backdrop-filter: blur(10px);
      display:none;
    }
    #panel h2 { margin: 2px 0 8px; font-size: 18px; }
    #panel p { margin: 0 0 10px; font-size: 14px; opacity:0.92; }
    #closeBtn{
      position:absolute;
      top:10px; right:10px;
      background: rgba(255,255,255,0.12);
      color:#fff; border:1px solid rgba(255,255,255,0.14);
      border-radius: 10px; padding: 6px 10px;
      cursor:pointer;
    }

    #footer{
      position: fixed;
      left: 12px; bottom: 12px;
      z-index: 5;
      color: rgba(255,255,255,0.65);
      font: 12px system-ui;
      background: rgba(0,0,0,0.25);
      padding: 6px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      user-select:none;
    }
    code { color: #d7e3ff; }
  </style>
</head>
<body>
  <div id="app"></div>

  <div id="hud">
    <div><strong>Controls:</strong> WASD move Â· Shift run Â· Space jump Â· Mouse drag rotate</div>
    <div id="hint">Tip: edit <code>MEMORIES</code> in the code.</div>
  </div>

  <div id="panel">
    <button id="closeBtn">Close</button>
    <h2 id="panelTitle"></h2>
    <p id="panelText"></p>
    <div id="panelExtra"></div>
  </div>

  <div id="footer">Built for us ðŸ’™</div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { FBXLoader } from "three/addons/loaders/FBXLoader.js";
    import * as SkeletonUtils from "three/addons/utils/SkeletonUtils.js";

    // ====== EDIT THESE ======
    const AVATAR_URL = "https://models.readyplayer.me/695c48e31c1817592c4ec48b.glb";

    // IMPORTANT: use RELATIVE paths so GitHub Pages always works
    const ANIMS = {
      Idle: "assets/anim/Idle.fbx",
      Walk: "assets/anim/Walk.fbx",
      Run:  "assets/anim/Run.fbx",
      Jump: "assets/anim/Jump.fbx",
    };

    const MEMORIES = [
      { id:"first-meet",  title:"How we met",        text:"Write a short story here.", pos:new THREE.Vector3(-6,0,-4) },
      { id:"first-date",  title:"First date",        text:"Where did you go? One detail you remember.", pos:new THREE.Vector3(6,0,-2) },
      { id:"moment",      title:"The moment I knew", text:"One moment that made it clear sheâ€™s your person.", pos:new THREE.Vector3(-2,0,7) },
      { id:"future",      title:"Whatâ€™s next",       text:"Something youâ€™re excited to do together this year.", pos:new THREE.Vector3(7,0,7) },
    ];

    // ====== Scene setup ======
    const app = document.getElementById("app");
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x05060a, 10, 55);

    const camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.1, 200);
    camera.position.set(0, 10, 14);

    // FIX: remove alpha:true (prevents transparency/depth issues with RPM)
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setClearColor(0x05060a, 1);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    app.appendChild(renderer.domElement);

    // Lights
    scene.add(new THREE.HemisphereLight(0xaecbff, 0x1a1d2b, 0.95));
    const dir = new THREE.DirectionalLight(0xffffff, 1.1);
    dir.position.set(12, 18, 10);
    dir.castShadow = true;
    dir.shadow.mapSize.set(1024, 1024);
    dir.shadow.camera.left = -25;
    dir.shadow.camera.right = 25;
    dir.shadow.camera.top = 25;
    dir.shadow.camera.bottom = -25;
    scene.add(dir);

    // Ground + walls
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(40, 40),
      new THREE.MeshStandardMaterial({ color: 0x0b1020, roughness:0.95, metalness:0 })
    );
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    const wallMat = new THREE.MeshStandardMaterial({ color: 0x111634, roughness: 0.9 });
    function wall(w,h,d,x,y,z){
      const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), wallMat);
      m.position.set(x,y,z);
      m.castShadow = true; m.receiveShadow = true;
      scene.add(m);
      return m;
    }
    wall(40, 2.5, 0.8, 0, 1.25, -20);
    wall(40, 2.5, 0.8, 0, 1.25, 20);
    wall(0.8, 2.5, 40, -20, 1.25, 0);
    wall(0.8, 2.5, 40, 20, 1.25, 0);

    // Some props
    const propMat = new THREE.MeshStandardMaterial({ color: 0x1a2250, roughness: 0.8 });
    function pillar(x,z){
      const p = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.8,3.2,18), propMat);
      p.position.set(x,1.6,z);
      p.castShadow = true; p.receiveShadow = true;
      scene.add(p);
    }
    pillar(-10,10); pillar(10,-10); pillar(0,0);

    // ====== Player (container) ======
    const player = new THREE.Group();
    player.position.set(0,0,8);
    scene.add(player);

    // temp cylinder so you see something while loading
    const tempCapsule = new THREE.Mesh(
      new THREE.CylinderGeometry(0.55, 0.55, 1.8, 16),
      new THREE.MeshStandardMaterial({ color:0x9fb6ff, roughness:0.35, metalness:0.1 })
    );
    tempCapsule.castShadow = true;
    tempCapsule.position.y = 1.0;
    player.add(tempCapsule);

    // ====== Load avatar + animations ======
    const gltfLoader = new GLTFLoader();
    const fbxLoader  = new FBXLoader();

    let avatarRoot = null;
    let mixer = null;
    const actions = {};
    let currentAction = null;

    function playAction(name, fade=0.18){
      const next = actions[name];
      if (!next) return;
      if (currentAction === next) return;

      if (currentAction) currentAction.fadeOut(fade);
      currentAction = next;
      currentAction.reset().fadeIn(fade).play();
    }

    function forceMeshRenderStability(root){
      root.traverse((o) => {
        if (o.isMesh) {
          o.castShadow = true;
          o.receiveShadow = true;
          o.frustumCulled = false;     // FIX: stop bounds culling issues
          o.visible = true;

          // FIX: RPM often uses transparent materials (hair/eyes/lashes).
          // This avoids "flash then vanish" depth-sorting bugs.
          const mats = Array.isArray(o.material) ? o.material : [o.material];
          for (const m of mats) {
            if (!m) continue;
            m.transparent = false;
            m.depthWrite = true;
            m.depthTest = true;
            m.needsUpdate = true;
          }
        }
      });
    }

    function loadAnimFBX(url){
      return new Promise((resolve, reject) => {
        fbxLoader.load(url, (fbx) => {
          const clip = fbx.animations && fbx.animations[0];
          if (!clip) return reject(new Error("No animation in " + url));
          resolve({ fbx, clip });
        }, undefined, reject);
      });
    }

    gltfLoader.load(AVATAR_URL, async (gltf) => {
      avatarRoot = gltf.scene;

      // Stabilize rendering
      forceMeshRenderStability(avatarRoot);

      // Ensure sane transforms
      avatarRoot.position.set(0,0,0);
      avatarRoot.rotation.set(0,0,0);
      avatarRoot.scale.set(1,1,1);

      // DEBUG: force geometry to be visible no matter what (ignore textures/transparency)
      avatarRoot.traverse((o) => {
        if (o.isMesh) {
          o.frustumCulled = false;
          o.castShadow = false;
          o.receiveShadow = false;
          o.material = new THREE.MeshNormalMaterial(); // <-- impossible to be invisible unless not rendered
          o.visible = true;
        }
      });

      player.add(avatarRoot);

      // DEBUG: show bounding box even if mesh/materials are broken
      const box = new THREE.BoxHelper(avatarRoot, 0xff0000);
      box.frustumCulled = false;
      scene.add(box);
      
      // keep updating it
      window.__avatarBox = box;
      window.__avatarRoot = avatarRoot;
      
      player.remove(tempCapsule);

      mixer = new THREE.AnimationMixer(avatarRoot);

      try{
        // Load the Mixamo animation sources
        const [idle, walk, run, jump] = await Promise.all([
          loadAnimFBX(ANIMS.Idle),
          loadAnimFBX(ANIMS.Walk),
          loadAnimFBX(ANIMS.Run),
          loadAnimFBX(ANIMS.Jump),
        ]);

        // Retarget clips to avatar using SkeletonUtils (more reliable than name-matching)
        const idleClip = SkeletonUtils.retargetClip(avatarRoot, idle.fbx, idle.clip, { preserveMatrix: false });
        const walkClip = SkeletonUtils.retargetClip(avatarRoot, walk.fbx, walk.clip, { preserveMatrix: false });
        const runClip  = SkeletonUtils.retargetClip(avatarRoot, run.fbx,  run.clip,  { preserveMatrix: false });
        const jumpClip = SkeletonUtils.retargetClip(avatarRoot, jump.fbx, jump.clip, { preserveMatrix: false });

        actions.Idle = mixer.clipAction(idleClip);
        actions.Walk = mixer.clipAction(walkClip);
        actions.Run  = mixer.clipAction(runClip);
        actions.Jump = mixer.clipAction(jumpClip);

        actions.Jump.loop = THREE.LoopOnce;
        actions.Jump.clampWhenFinished = true;

        console.log("Animations ready:", Object.keys(actions));
        playAction("Idle", 0.0);

      } catch (e){
        console.error("Animation load/retarget failed:", e);
      }

    }, undefined, (e) => console.error("Avatar load failed:", e));

    // ====== Camera controls ======
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.minDistance = 6;
    controls.maxDistance = 24;
    controls.maxPolarAngle = Math.PI * 0.49;
    controls.target.copy(player.position).add(new THREE.Vector3(0, 1.2, 0));

    // ====== Memory spots ======
    const spots = [];
    const spotGeo = new THREE.TorusGeometry(1.0, 0.12, 16, 50);
    const glowMat = new THREE.MeshStandardMaterial({
      color: 0x7da6ff,
      emissive: 0x3b66ff,
      emissiveIntensity: 1.6,
      roughness: 0.2,
      metalness: 0.25
    });

    for (const mem of MEMORIES) {
      const ring = new THREE.Mesh(spotGeo, glowMat.clone());
      ring.rotation.x = Math.PI / 2;
      ring.position.copy(mem.pos);
      ring.position.y = 0.12;
      ring.receiveShadow = true;
      scene.add(ring);

      const marker = new THREE.Mesh(
        new THREE.SphereGeometry(0.18, 18, 18),
        new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x7da6ff, emissiveIntensity: 1.2 })
      );
      marker.position.copy(mem.pos);
      marker.position.y = 1.35;
      marker.castShadow = true;
      scene.add(marker);

      spots.push({ mem, ring, marker });
    }

    // ====== UI panel ======
    const panel = document.getElementById("panel");
    const panelTitle = document.getElementById("panelTitle");
    const panelText = document.getElementById("panelText");
    document.getElementById("closeBtn").onclick = () => {
      panel.style.display = "none";
      activeSpotId = null;
    };

    let activeSpotId = null;
    function openMemory(mem){
      activeSpotId = mem.id;
      panelTitle.textContent = mem.title;
      panelText.textContent = mem.text;
      panel.style.display = "block";
    }

    // ====== Movement + animation switching ======
    const keys = new Set();
    let isJumping = false;
    let jumpCooldown = 0;

    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      keys.add(k);

      if ((k === " " || k === "spacebar") && !isJumping && jumpCooldown <= 0) {
        isJumping = true;
        jumpCooldown = 0.65;
        playAction("Jump", 0.05);
      }
    });
    window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

    const clock = new THREE.Clock();
    const tmpVec = new THREE.Vector3();

    function clampToMap(pos) {
      pos.x = Math.max(-18.5, Math.min(18.5, pos.x));
      pos.z = Math.max(-18.5, Math.min(18.5, pos.z));
    }

    function updatePlayer(dt){
      const isRunning = keys.has("shift");
      const speed = isRunning ? 6.2 : 4.2;

      let forward = 0, right = 0;
      if (keys.has("w")) forward += 1;
      if (keys.has("s")) forward -= 1;
      if (keys.has("d")) right += 1;
      if (keys.has("a")) right -= 1;

      const yaw = controls.getAzimuthalAngle();

      // W forward, S backward
      const dirF = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw)).normalize();
      const dirR = new THREE.Vector3(dirF.z, 0, -dirF.x).normalize();

      tmpVec.set(0,0,0);
      tmpVec.addScaledVector(dirF, forward);
      tmpVec.addScaledVector(dirR, right);

      const isMoving = tmpVec.lengthSq() > 0;

      if (isMoving && !isJumping) {
        tmpVec.normalize().multiplyScalar(speed * dt);
        player.position.add(tmpVec);
        clampToMap(player.position);

        const look = player.position.clone().add(tmpVec.clone().normalize());
        player.lookAt(look.x, player.position.y, look.z);
      }

      controls.target.copy(player.position).add(new THREE.Vector3(0, 1.2, 0));

      if (Object.keys(actions).length) {
        if (isJumping) playAction("Jump");
        else if (isMoving && isRunning) playAction("Run");
        else if (isMoving) playAction("Walk");
        else playAction("Idle");
      }
    }

    function checkMemoryTriggers(){
      let closest = null;
      let closestDist = Infinity;

      for (const s of spots) {
        const d = player.position.distanceTo(s.mem.pos);
        if (d < closestDist) { closestDist = d; closest = s; }
      }

      if (closest && closestDist <= 2.1) {
        if (activeSpotId !== closest.mem.id) openMemory(closest.mem);
      }
    }

    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.033);

      updatePlayer(dt);

      if (jumpCooldown > 0) {
        jumpCooldown -= dt;
        if (jumpCooldown <= 0) isJumping = false;
      }

      const t = clock.elapsedTime;
      for (const s of spots) {
        s.ring.rotation.z = t * 0.7;
        s.marker.position.y = 1.35 + Math.sin(t * 2.2 + s.mem.pos.x) * 0.08;
      }

      if (mixer) mixer.update(dt);

      checkMemoryTriggers();
      controls.update();
      renderer.render(scene, camera);

      if (window.__avatarBox && window.__avatarRoot) window.__avatarBox.update();
      
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
