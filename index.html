<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Our 1 Year</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#05060a; }
    #app { position:fixed; inset:0; }

    #hud{
      position: fixed;
      left: 12px; top: 12px;
      color: rgba(255,255,255,0.9);
      font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      z-index: 5;
      user-select:none;
      background: rgba(0,0,0,0.35);
      padding: 10px 12px;
      border-radius: 12px;
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.12);
      max-width: 420px;
    }
    #hint { opacity:0.85; margin-top:6px; font-size:13px; }

    #panel{
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: min(520px, calc(100vw - 28px));
      max-height: min(60vh, 520px);
      overflow:auto;
      z-index: 6;
      background: rgba(10,12,18,0.86);
      color: rgba(255,255,255,0.92);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 18px;
      padding: 14px 14px 12px;
      backdrop-filter: blur(10px);
      display:none;
    }
    #panel h2 { margin: 2px 0 8px; font-size: 18px; }
    #panel p { margin: 0 0 10px; font-size: 14px; opacity:0.92; }
    #closeBtn{
      position:absolute;
      top:10px; right:10px;
      background: rgba(255,255,255,0.12);
      color:#fff; border:1px solid rgba(255,255,255,0.14);
      border-radius: 10px; padding: 6px 10px;
      cursor:pointer;
    }

    #footer{
      position: fixed;
      left: 12px; bottom: 12px;
      z-index: 5;
      color: rgba(255,255,255,0.65);
      font: 12px system-ui;
      background: rgba(0,0,0,0.25);
      padding: 6px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      user-select:none;
    }
    code { color: #d7e3ff; }
  </style>
</head>
<body>
  <div id="app"></div>

  <div id="hud">
    <div><strong>Controls:</strong> WASD move Â· Shift run Â· Space jump Â· Mouse drag rotate Â· 1/2/3 dance</div>
    <div id="hint">Tip: edit <code>MEMORIES</code> in the code.</div>
  </div>

  <div id="panel">
    <button id="closeBtn">Close</button>
    <h2 id="panelTitle"></h2>
    <p id="panelText"></p>
  </div>

  <div id="footer">Built for us ðŸ’™</div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

<script type="module">
  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { FBXLoader } from "three/addons/loaders/FBXLoader.js";
  import { Sky } from "three/addons/objects/Sky.js";

  // ====== EDIT THESE ======
  const AVATAR_URL = "https://models.readyplayer.me/695c48e31c1817592c4ec48b.glb";
  const ANIMS = {
    Idle: "assets/anim/Idle.fbx",
    Walk: "assets/anim/Walk.fbx",
    Run:  "assets/anim/Run.fbx",
    Jump: "assets/anim/Jump.fbx",
    Samba: "assets/anim/Samba.fbx",
    Rumba: "assets/anim/Rumba.fbx",
    Salsa: "assets/anim/Salsa.fbx",
  };

  const MEMORIES = [
    { id:"first-meet", title:"How we met", text:"Write a short story here.", pos:new THREE.Vector3(-6,0,-4) },
    { id:"first-date", title:"First date", text:"Where did you go? One detail you remember.", pos:new THREE.Vector3(6,0,-2) },
    { id:"moment", title:"The moment I knew", text:"One moment that made it clear sheâ€™s your person.", pos:new THREE.Vector3(-2,0,7) },
    { id:"future", title:"Whatâ€™s next", text:"Something youâ€™re excited to do together this year.", pos:new THREE.Vector3(7,0,7) },
  ];

  // ====== Tuning ======
  const WALK_SPEED = 2.6;
  const RUN_SPEED  = 8.0;
  const AIR_CONTROL = 0.65;

  const GRAVITY = -18.0;
  const JUMP_VEL = 6.4;

  const LOOK_HEIGHT = 1.45;
  const MIN_TRACKS_FOR_RUN = 40;

  const STEP_INTERVAL_WALK = 0.42;
  const STEP_INTERVAL_RUN  = 0.28;

  const MAP_RADIUS = 55;
  const TERRAIN_SIZE = 120;
  const TERRAIN_SEG = 140;

  let grassWindAccum = 0;

  // ====== Small utilities ======
  function fract(x){ return x - Math.floor(x); }

  function hash2(x, z) {
    // IMPORTANT: JS % can be negative. Use fract().
    return fract(Math.sin(x * 127.1 + z * 311.7) * 43758.5453123);
  }

  function terrainHeight(x, z) {
    const h1 = Math.sin(x * 0.06) * 1.2 + Math.cos(z * 0.05) * 1.1;
    const h2 = Math.sin((x + z) * 0.035) * 1.6;
    const n  = (hash2(x * 0.35, z * 0.35) - 0.5) * 0.35;
    let h = (h1 + h2) * 0.8 + n;

    const d = Math.hypot(x, z);
    const flat = THREE.MathUtils.smoothstep(d, 0, 18);
    h *= (1.0 - flat * 0.75);

    return h;
  }

  function normalizeKey(name) {
    return String(name || "")
      .replace(/^Armature\|/i, "")
      .replace(/^mixamorig/i, "")
      .replace(/[^a-z0-9]/gi, "")
      .toLowerCase();
  }

  function buildBoneKeyToNameMap(root) {
    const map = new Map();
    root.traverse((o) => {
      if (!o.isBone) return;
      const key = normalizeKey(o.name);
      if (key && !map.has(key)) map.set(key, o.name);
    });
    return map;
  }

  function stripRootTranslation(clip) {
    const tracks = clip.tracks.filter((t) => !t.name.toLowerCase().endsWith(".position"));
    return new THREE.AnimationClip(clip.name, clip.duration, tracks);
  }

  function remapClipToAvatarBones(clip, avatarRoot, debugLabel) {
    const boneMap = buildBoneKeyToNameMap(avatarRoot);
    const outTracks = [];
    for (const tr of clip.tracks) {
      const parts = tr.name.split(".");
      if (parts.length < 2) continue;

      const srcNode = parts[0];
      const prop = parts.slice(1).join(".");
      const key = normalizeKey(srcNode);
      const dstBoneName = boneMap.get(key);
      if (!dstBoneName) continue;

      const dstTrackName = `${dstBoneName}.${prop}`;
      const times = tr.times.slice();
      const values = tr.values.slice();

      if (tr.ValueTypeName === "quaternion") {
        outTracks.push(new THREE.QuaternionKeyframeTrack(dstTrackName, times, values));
      } else if (tr.ValueTypeName === "vector") {
        outTracks.push(new THREE.VectorKeyframeTrack(dstTrackName, times, values));
      }
    }
    return new THREE.AnimationClip(clip.name || debugLabel, clip.duration, outTracks);
  }

  function forceMeshVisible(root) {
    root.traverse((o) => {
      if (!o.isMesh) return;
      o.frustumCulled = false;
      o.visible = true;
      o.castShadow = true;
      o.receiveShadow = true;

      const mats = Array.isArray(o.material) ? o.material : [o.material];
      for (const m of mats) {
        if (!m) continue;
        m.depthWrite = true;
        m.depthTest = true;
        m.needsUpdate = true;
        // IMPORTANT: kill env reflections to avoid black IBL issues
        if ("envMapIntensity" in m) m.envMapIntensity = 0.0;
      }
    });
  }

  // ====== Scene setup ======
  const app = document.getElementById("app");
  const scene = new THREE.Scene();

  // Stable background/fog (no day-night fog to black)
  scene.background = new THREE.Color(0xbad8ff);
  scene.fog = new THREE.Fog(0xbad8ff, 55, 170);

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);

  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.12;
  renderer.outputColorSpace = THREE.SRGBColorSpace;

  // DO NOT use scene.environment / PMREM here (this is what made your world go black)
  scene.environment = null;

  app.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 260);
  camera.position.set(0, 4, 6);

  // ====== Sky (visual only) ======
  const sky = new Sky();
  sky.scale.setScalar(450000);
  scene.add(sky);

  const skyU = sky.material.uniforms;
  skyU["turbidity"].value = 4;
  skyU["rayleigh"].value = 2.0;
  skyU["mieCoefficient"].value = 0.002;
  skyU["mieDirectionalG"].value = 0.85;

  // Fixed sun direction (always daylight)
  const sunDir = new THREE.Vector3(0.45, 1.0, 0.25).normalize();
  sky.material.uniforms.sunPosition.value.copy(sunDir);

  // ====== Lights (stable daylight rig) ======
  const sunLight = new THREE.DirectionalLight(0xffffff, 3.0);
  sunLight.position.copy(sunDir).multiplyScalar(120);
  sunLight.castShadow = true;

  sunLight.shadow.mapSize.set(2048, 2048);
  const SHADOW_BOX = 60;
  sunLight.shadow.camera.near = 1;
  sunLight.shadow.camera.far  = 250;
  sunLight.shadow.camera.left   = -SHADOW_BOX;
  sunLight.shadow.camera.right  =  SHADOW_BOX;
  sunLight.shadow.camera.top    =  SHADOW_BOX;
  sunLight.shadow.camera.bottom = -SHADOW_BOX;
  sunLight.shadow.bias = -0.00005;
  sunLight.shadow.normalBias = 0.01;

  const sunTarget = new THREE.Object3D();
  sunTarget.position.set(0, 0, 0);
  scene.add(sunTarget);
  sunLight.target = sunTarget;
  sunLight.target.updateMatrixWorld();

  scene.add(sunLight);

  const fill = new THREE.DirectionalLight(0xffffff, 1.0);
  fill.position.set(-80, 60, -60);
  fill.castShadow = false;
  scene.add(fill);

  const hemi = new THREE.HemisphereLight(0xd9f0ff, 0x2b3a2b, 1.0);
  scene.add(hemi);

  scene.add(new THREE.AmbientLight(0xffffff, 0.28));

  // ====== Better Clouds (FBM noise + multi-layer billboards) ======
  function makeFBMCloudTexture(size=512) {
    const c = document.createElement("canvas");
    c.width = c.height = size;
    const g = c.getContext("2d");
    const img = g.createImageData(size, size);
  
    function fract(x){ return x - Math.floor(x); }
    function hash(x,y){
      return fract(Math.sin(x*127.1 + y*311.7)*43758.5453);
    }
    function noise(x,y){
      const ix = Math.floor(x), iy = Math.floor(y);
      const fx = x - ix, fy = y - iy;
      const a = hash(ix,iy);
      const b = hash(ix+1,iy);
      const c = hash(ix,iy+1);
      const d = hash(ix+1,iy+1);
      const ux = fx*fx*(3.0-2.0*fx);
      const uy = fy*fy*(3.0-2.0*fy);
      return (a*(1-ux)+b*ux)*(1-uy) + (c*(1-ux)+d*ux)*uy;
    }
    function fbm(x,y){
      let v = 0, a = 0.5;
      for (let i=0;i<6;i++){
        v += a * noise(x,y);
        x *= 2.02; y *= 2.02;
        a *= 0.5;
      }
      return v;
    }
  
    for (let y=0;y<size;y++){
      for (let x=0;x<size;x++){
        const nx = x / size, ny = y / size;
  
        // FBM with shaping: concentrate â€œpuffsâ€
        let n = fbm(nx*4.0, ny*2.0);
        n = Math.pow(n, 1.55);
  
        // soft edges vignette so each card looks cloud-like
        const vx = (nx-0.5)*2.0;
        const vy = (ny-0.5)*2.0;
        const vign = Math.max(0.0, 1.0 - (vx*vx*0.9 + vy*vy*1.8));
  
        // alpha
        const a = THREE.MathUtils.clamp((n*1.25 - 0.35) * vign, 0, 1);
  
        // slight internal lighting (bright center)
        const light = 0.65 + 0.35 * vign;
        const col = Math.floor(255 * light);
  
        const i = (y*size + x)*4;
        img.data[i+0] = col;
        img.data[i+1] = col;
        img.data[i+2] = col;
        img.data[i+3] = Math.floor(a * 255);
      }
    }
  
    g.putImageData(img, 0, 0);
  
    const tex = new THREE.CanvasTexture(c);
    tex.colorSpace = THREE.SRGBColorSpace;
    tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
    tex.needsUpdate = true;
    return tex;
  }
  
  const clouds = new THREE.Group();
  scene.add(clouds);
  
  const cloudTex = makeFBMCloudTexture(512);
  
  const cloudMat = new THREE.MeshLambertMaterial({
    map: cloudTex,
    transparent: true,
    depthWrite: false,
    opacity: 0.95
  });
  
  // one cloud = several layers for fake volume
  function addCloud(x,y,z,scale=1){
    const layers = 5;
    const group = new THREE.Group();
    for (let i=0;i<layers;i++){
      const w = (18 + Math.random()*18) * scale;
      const h = w * (0.45 + Math.random()*0.25);
  
      const m = new THREE.Mesh(new THREE.PlaneGeometry(w,h), cloudMat);
      m.position.set(
        (Math.random()-0.5) * 2.2 * scale,
        (Math.random()-0.5) * 1.2 * scale,
        i * 0.65 * scale
      );
      m.rotation.y = Math.random() * Math.PI*2;
      m.renderOrder = 10 + i;
      group.add(m);
    }
    group.position.set(x,y,z);
    group.userData = { speed: 0.25 + Math.random()*0.35, wob: Math.random()*10 };
    clouds.add(group);
  }
  
  // scatter clouds
  for (let i=0;i<14;i++){
    addCloud(
      (Math.random()-0.5)*150,
      28 + Math.random()*18,
      (Math.random()-0.5)*150,
      0.9 + Math.random()*1.2
    );
  }
  
  function updateClouds(dt, time){
    for (const c of clouds.children){
      c.position.x += dt * (c.userData.speed * 6.0);
      c.position.z += dt * (c.userData.speed * 1.8);
  
      // gentle altitude wobble
      c.position.y += Math.sin(time*0.25 + c.userData.wob) * dt * 0.15;
  
      // wrap
      if (c.position.x > 95) c.position.x = -95;
      if (c.position.z > 95) c.position.z = -95;
  
      // billboard each layer to camera
      for (const layer of c.children){
        layer.lookAt(camera.position.x, layer.getWorldPosition(new THREE.Vector3()).y, camera.position.z);
      }
    }
  }

  // ====== Grass maps ======
  function makeGrassMaps() {
    const size = 512;

    const c0 = document.createElement("canvas");
    c0.width = c0.height = size;
    const g0 = c0.getContext("2d");

    g0.fillStyle = "#0b2411";
    g0.fillRect(0,0,size,size);

    for (let i=0;i<14000;i++){
      const x = (Math.random()*size)|0;
      const y = (Math.random()*size)|0;
      const v = 50 + (Math.random()*90)|0;
      const r = 10 + (Math.random()*20)|0;
      g0.fillStyle = `rgb(${r},${v},${20})`;
      g0.fillRect(x,y,1,1);
    }

    g0.globalAlpha = 0.35;
    for (let i=0;i<2800;i++){
      const x = Math.random()*size;
      const y = Math.random()*size;
      const len = 2 + Math.random()*6;
      const ang = Math.random()*Math.PI*2;
      g0.strokeStyle = "rgba(160,255,190,0.20)";
      g0.lineWidth = 1;
      g0.beginPath();
      g0.moveTo(x,y);
      g0.lineTo(x + Math.cos(ang)*len, y + Math.sin(ang)*len);
      g0.stroke();
    }
    g0.globalAlpha = 1;

    const cN = document.createElement("canvas");
    cN.width = cN.height = size;
    const gN = cN.getContext("2d");
    const imgN = gN.createImageData(size,size);

    function heightAt(x,y){
      const n = Math.sin(x*12.9898 + y*78.233) * 43758.5453;
      return n - Math.floor(n);
    }

    for (let y=0;y<size;y++){
      for (let x=0;x<size;x++){
        const hL = heightAt(x-1,y);
        const hR = heightAt(x+1,y);
        const hD = heightAt(x,y-1);
        const hU = heightAt(x,y+1);

        const dx = (hR - hL) * 1.2;
        const dy = (hU - hD) * 1.2;

        let nx = -dx, ny = -dy, nz = 1.0;
        const inv = 1 / Math.hypot(nx,ny,nz);
        nx*=inv; ny*=inv; nz*=inv;

        const i = (y*size + x)*4;
        imgN.data[i+0] = ((nx*0.5+0.5)*255)|0;
        imgN.data[i+1] = ((ny*0.5+0.5)*255)|0;
        imgN.data[i+2] = ((nz*0.5+0.5)*255)|0;
        imgN.data[i+3] = 255;
      }
    }
    gN.putImageData(imgN,0,0);

    const cR = document.createElement("canvas");
    cR.width = cR.height = size;
    const gR = cR.getContext("2d");
    const imgR = gR.createImageData(size,size);
    for (let y=0;y<size;y++){
      for (let x=0;x<size;x++){
        const h = heightAt(x,y);
        const r = (170 + h*70)|0;
        const i = (y*size + x)*4;
        imgR.data[i+0] = r;
        imgR.data[i+1] = r;
        imgR.data[i+2] = r;
        imgR.data[i+3] = 255;
      }
    }
    gR.putImageData(imgR,0,0);

    const map = new THREE.CanvasTexture(c0);
    map.colorSpace = THREE.SRGBColorSpace;
    map.wrapS = map.wrapT = THREE.RepeatWrapping;

    const normalMap = new THREE.CanvasTexture(cN);
    normalMap.wrapS = normalMap.wrapT = THREE.RepeatWrapping;

    const roughnessMap = new THREE.CanvasTexture(cR);
    roughnessMap.wrapS = roughnessMap.wrapT = THREE.RepeatWrapping;

    return { map, normalMap, roughnessMap };
  }

  const { map:grassMap, normalMap:grassNormal, roughnessMap:grassRough } = makeGrassMaps();
  grassMap.repeat.set(14,14);
  grassNormal.repeat.set(14,14);
  grassRough.repeat.set(14,14);

  // ====== Terrain ======
  const terrainGeo = new THREE.PlaneGeometry(TERRAIN_SIZE, TERRAIN_SIZE, TERRAIN_SEG, TERRAIN_SEG);
  terrainGeo.rotateX(-Math.PI / 2);

  const posAttr = terrainGeo.attributes.position;
  for (let i = 0; i < posAttr.count; i++) {
    const x = posAttr.getX(i);
    const z = posAttr.getZ(i);
    const y = terrainHeight(x, z);
    posAttr.setY(i, y);
  }
  terrainGeo.computeVertexNormals();

  const terrainMat = new THREE.MeshStandardMaterial({
    map: grassMap,
    normalMap: grassNormal,
    roughnessMap: grassRough,
    color: 0xffffff,
    roughness: 1.0,
    metalness: 0.0,
    envMapIntensity: 0.0
  });

  terrainMat.onBeforeCompile = (shader) => {
    shader.fragmentShader = shader.fragmentShader.replace(
      "#include <dithering_fragment>",
      `
        // subtle height tint variation (breaks repetition)
        float h = vViewPosition.y; // view space-ish but good enough
        vec3 tint = mix(vec3(1.0, 1.0, 1.0), vec3(0.92, 1.03, 0.92), smoothstep(-2.0, 2.0, h));
        gl_FragColor.rgb *= tint;
        #include <dithering_fragment>
      `
    );
  };
  terrainMat.needsUpdate = true;
  
  const ground = new THREE.Mesh(terrainGeo, terrainMat);
  ground.receiveShadow = true;
  scene.add(ground);

  function placeOnTerrain(obj, x, z, yOffset = 0) {
    obj.position.set(x, terrainHeight(x, z) + yOffset, z);
  }

  function addRock(x, z, s = 1) {
    const g = new THREE.IcosahedronGeometry(0.9 * s, 1);
    const m = new THREE.MeshStandardMaterial({ color: 0x3a3f4a, roughness: 0.95, metalness: 0.0, envMapIntensity: 0.0 });
    const rock = new THREE.Mesh(g, m);
    rock.castShadow = true;
    rock.receiveShadow = true;
    placeOnTerrain(rock, x, z, 0.1);
    rock.rotation.y = Math.random() * Math.PI * 2;
    scene.add(rock);
  }

  function addTree(x, z, s = 1) {
    const trunk = new THREE.Mesh(
      new THREE.CylinderGeometry(0.15 * s, 0.22 * s, 2.2 * s, 10),
      new THREE.MeshStandardMaterial({ color: 0x4a2e1d, roughness: 1, metalness: 0, envMapIntensity: 0.0 })
    );
    const crown = new THREE.Mesh(
      new THREE.SphereGeometry(1.1 * s, 14, 14),
      new THREE.MeshStandardMaterial({ color: 0x1e4a25, roughness: 1, metalness: 0, envMapIntensity: 0.0 })
    );
    trunk.castShadow = crown.castShadow = true;
    trunk.receiveShadow = crown.receiveShadow = true;

    const tree = new THREE.Group();
    tree.add(trunk);
    crown.position.y = 1.5 * s;
    tree.add(crown);

    placeOnTerrain(tree, x, z, 0);
    trunk.position.y = 1.1 * s;

    scene.add(tree);
  }

  function scatterScene() {
    for (let i = 0; i < 70; i++) {
      const a = Math.random() * Math.PI * 2;
      const r = 30 + Math.random() * 22;
      const x = Math.cos(a) * r;
      const z = Math.sin(a) * r;
      addTree(x, z, 0.85 + Math.random() * 0.6);
    }

    for (let i = 0; i < 45; i++) {
      const x = (Math.random() - 0.5) * 90;
      const z = (Math.random() - 0.5) * 90;
      if (Math.hypot(x, z) < 16) continue;
      addRock(x, z, 0.6 + Math.random() * 1.3);
    }

    const pathMat = new THREE.MeshStandardMaterial({ color: 0x3a3a2f, roughness: 1, metalness: 0, envMapIntensity: 0.0 });
    for (let i = 0; i < 26; i++) {
      const t = i / 25;
      const x = THREE.MathUtils.lerp(-18, 22, t);
      const z = Math.sin(t * Math.PI * 2) * 8;
      const y = terrainHeight(x, z) + 0.02;
      const p = new THREE.Mesh(new THREE.CircleGeometry(2.2, 18), pathMat);
      p.rotation.x = -Math.PI / 2;
      p.position.set(x, y, z);
      p.receiveShadow = true;
      scene.add(p);
    }
  }
  scatterScene();

  // ====== Proper Grass (shader blades: wind + player interaction) ======
  function makeGrassField({
    count = 65000,
    radius = MAP_RADIUS - 2,
    bladeH = 0.65,
    bladeW = 0.06
  } = {}) {
  
    // A single blade: vertical plane subdivided so it can bend smoothly
    const bladeGeo = new THREE.PlaneGeometry(bladeW, bladeH, 1, 4);
    bladeGeo.translate(0, bladeH * 0.5, 0); // root at y=0
  
    // Instanced attributes
    const offsets = new Float32Array(count * 3);
    const scales  = new Float32Array(count);
    const yaws    = new Float32Array(count);
    const phases  = new Float32Array(count);
  
    for (let i = 0; i < count; i++) {
      const a = Math.random() * Math.PI * 2;
      const r = Math.sqrt(Math.random()) * radius;
      const x = Math.cos(a) * r;
      const z = Math.sin(a) * r;
      const y = terrainHeight(x, z);
  
      offsets[i*3+0] = x;
      offsets[i*3+1] = y;
      offsets[i*3+2] = z;
  
      scales[i] = 0.6 + Math.random() * 1.25;       // size variance
      yaws[i]   = Math.random() * Math.PI * 2;      // random rotation
      phases[i] = Math.random() * 10.0;             // wind phase
    }
  
    const instGeo = new THREE.InstancedBufferGeometry();
    instGeo.index = bladeGeo.index;
    instGeo.attributes.position = bladeGeo.attributes.position;
    instGeo.attributes.uv = bladeGeo.attributes.uv;
    instGeo.attributes.normal = bladeGeo.attributes.normal;
  
    instGeo.setAttribute("iOffset", new THREE.InstancedBufferAttribute(offsets, 3));
    instGeo.setAttribute("iScale",  new THREE.InstancedBufferAttribute(scales, 1));
    instGeo.setAttribute("iYaw",    new THREE.InstancedBufferAttribute(yaws, 1));
    instGeo.setAttribute("iPhase",  new THREE.InstancedBufferAttribute(phases, 1));
  
    const mat = new THREE.ShaderMaterial({
      transparent: true,
      depthWrite: true,
      side: THREE.DoubleSide,
      uniforms: {
        uTime: { value: 0 },
        uPlayerPos: { value: new THREE.Vector3() },
        uWindDir: { value: new THREE.Vector2(0.8, 0.2).normalize() },
        uWindStrength: { value: 1.0 },
        uInteractRadius: { value: 1.2 },   // how close to bend
        uInteractStrength: { value: 0.65 } // bend intensity
      },
      vertexShader: `
        precision highp float;
  
        attribute vec3 iOffset;
        attribute float iScale;
        attribute float iYaw;
        attribute float iPhase;
  
        uniform float uTime;
        uniform vec3 uPlayerPos;
        uniform vec2 uWindDir;
        uniform float uWindStrength;
        uniform float uInteractRadius;
        uniform float uInteractStrength;
  
        varying vec2 vUv;
        varying float vShade;
  
        mat2 rot(float a){
          float s = sin(a), c = cos(a);
          return mat2(c,-s,s,c);
        }
  
        void main(){
          vUv = uv;
  
          // Base blade
          vec3 p = position;
          p.y *= iScale;
  
          // rotate blade around Y
          vec2 xz = rot(iYaw) * p.xz;
          p.x = xz.x;
          p.z = xz.y;
  
          // Wind: stronger towards tip (uv.y)
          float tip = smoothstep(0.15, 1.0, uv.y);
          float w = sin(uTime * 1.45 + iPhase) * 0.08
                  + sin(uTime * 0.75 + iPhase * 1.7) * 0.05;
  
          vec2 wind = uWindDir * w * uWindStrength;
          p.xz += wind * tip * (0.9 + 0.25 * iScale);
  
          // Player interaction: bend away from player within radius
          vec3 worldRoot = iOffset;
          vec2 toPlayer = (worldRoot.xz - uPlayerPos.xz);
          float d = length(toPlayer);
          float influence = 1.0 - smoothstep(0.0, uInteractRadius, d);
          vec2 pushDir = (d > 0.0001) ? normalize(toPlayer) : vec2(0.0, 1.0);
  
          // push near tip more than base
          p.xz += pushDir * (influence * uInteractStrength) * tip;
  
          // move into world
          vec3 worldPos = p + iOffset;
  
          // simple shading factor: darker at base
          vShade = 0.55 + 0.45 * uv.y;
  
          gl_Position = projectionMatrix * modelViewMatrix * vec4(worldPos, 1.0);
        }
      `,
      fragmentShader: `
        precision highp float;
        varying vec2 vUv;
        varying float vShade;
  
        void main(){
          // Soft blade alpha: thin tip, no hard rectangle
          float edge = smoothstep(0.02, 0.18, vUv.x) * (1.0 - smoothstep(0.82, 0.98, vUv.x));
          float tip  = smoothstep(1.0, 0.65, vUv.y); // fade near top slightly
          float a = edge * (0.85 + 0.15 * tip);
  
          // color gradient base->tip (more realistic than single green)
          vec3 base = vec3(0.06, 0.22, 0.08);
          vec3 mid  = vec3(0.10, 0.40, 0.14);
          vec3 top  = vec3(0.18, 0.55, 0.20);
  
          vec3 col = mix(base, mid, smoothstep(0.0, 0.65, vUv.y));
          col = mix(col, top, smoothstep(0.55, 1.0, vUv.y));
          col *= vShade;
  
          // discard near-zero alpha for performance
          if (a < 0.03) discard;
  
          gl_FragColor = vec4(col, a);
        }
      `
    });
  
    const mesh = new THREE.Mesh(instGeo, mat);
    mesh.frustumCulled = false;
    mesh.castShadow = false;
    mesh.receiveShadow = false;
  
    return { mesh, mat };
  }
  
  // create grass
  const grassField = makeGrassField({
    count: 90000,      // adjust performance
    radius: MAP_RADIUS - 2,
    bladeH: 0.72,
    bladeW: 0.06
  });
  scene.add(grassField.mesh);

  // ====== Props ======
  const propMat = new THREE.MeshStandardMaterial({
    color: 0x1a2250,
    roughness: 0.75,
    metalness: 0.05,
    envMapIntensity: 0.0
  });

  function pillar(x,z){
    const p = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.8,3.2,18), propMat);
    p.position.set(x,1.6,z);
    p.castShadow = true;
    p.receiveShadow = true;
    scene.add(p);
  }
  pillar(-10,10); pillar(10,-10); pillar(0,0);

  // ====== Player container ======
  const player = new THREE.Group();
  player.position.set(0, 0, 8);
  scene.add(player);

  const playerVisual = new THREE.Group();
  player.add(playerVisual);

  // ====== Orbit camera ======
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.enablePan = false;
  controls.enableZoom = true;
  controls.zoomSpeed = 0.9;

  controls.minDistance = 2.6;
  controls.maxDistance = 7.0;
  controls.minPolarAngle = 0.15;
  controls.maxPolarAngle = Math.PI * 0.48;
  controls.rotateSpeed = 0.6;

  controls.target.copy(player.position).add(new THREE.Vector3(0, LOOK_HEIGHT, 0));
  controls.update();

  // ====== Memory spots ======
  const spots = [];
  const spotGeo = new THREE.TorusGeometry(1.0, 0.12, 16, 50);

  const glowBase = new THREE.MeshStandardMaterial({
    color: 0x7da6ff,
    emissive: 0x3b66ff,
    emissiveIntensity: 1.6,
    roughness: 0.25,
    metalness: 0.0,
    envMapIntensity: 0.0
  });

  for (const mem of MEMORIES) {
    const ring = new THREE.Mesh(spotGeo, glowBase.clone());
    ring.rotation.x = Math.PI / 2;
    ring.position.copy(mem.pos);
    ring.position.y = 0.12;
    ring.receiveShadow = true;
    ring.castShadow = false;
    scene.add(ring);

    const marker = new THREE.Mesh(
      new THREE.SphereGeometry(0.18, 18, 18),
      new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: 0x7da6ff,
        emissiveIntensity: 1.0,
        roughness: 0.2,
        metalness: 0.0,
        envMapIntensity: 0.0
      })
    );
    marker.position.copy(mem.pos);
    marker.position.y = 1.35;
    marker.castShadow = true;
    scene.add(marker);

    spots.push({ mem, ring, marker });
  }

  // ====== UI panel ======
  const panel = document.getElementById("panel");
  const panelTitle = document.getElementById("panelTitle");
  const panelText = document.getElementById("panelText");
  document.getElementById("closeBtn").onclick = () => {
    panel.style.display = "none";
    activeSpotId = null;
  };

  let activeSpotId = null;
  function openMemory(mem){
    activeSpotId = mem.id;
    panelTitle.textContent = mem.title;
    panelText.textContent = mem.text;
    panel.style.display = "block";
  }

  // ====== Avatar + Animations ======
  const gltfLoader = new GLTFLoader();
  const fbxLoader  = new FBXLoader();

  let avatarRoot = null;
  let mixer = null;
  const actions = {};
  let currentAction = null;

  function playAction(name, fade=0.14){
    const next = actions[name];
    if (!next) return;
    if (currentAction === next) return;

    if (currentAction) currentAction.fadeOut(fade);
    currentAction = next;
    currentAction.reset().fadeIn(fade).play();
  }

  function loadFBX(url){
    return new Promise((resolve, reject) => {
      fbxLoader.load(url, (fbx) => {
        const clip = fbx.animations && fbx.animations[0];
        if (!clip) return reject(new Error("No animation in " + url));
        resolve(clip);
      }, undefined, reject);
    });
  }

  let jumpAnimDone = false;
  let danceActive = null;

  async function setupAvatarAndAnims(){
    const gltf = await new Promise((resolve, reject) => {
      gltfLoader.load(AVATAR_URL, resolve, undefined, reject);
    });

    avatarRoot = gltf.scene;
    forceMeshVisible(avatarRoot);

    avatarRoot.position.set(0,0,0);
    avatarRoot.rotation.set(0,0,0);
    avatarRoot.scale.set(1,1,1);
    playerVisual.add(avatarRoot);

    mixer = new THREE.AnimationMixer(avatarRoot);

    const [idleRaw, walkRaw, runRaw, jumpRaw, sambaRaw, rumbaRaw, salsaRaw] = await Promise.all([
      loadFBX(ANIMS.Idle),
      loadFBX(ANIMS.Walk),
      loadFBX(ANIMS.Run),
      loadFBX(ANIMS.Jump),
      loadFBX(ANIMS.Samba),
      loadFBX(ANIMS.Rumba),
      loadFBX(ANIMS.Salsa),
    ]);

    const idle  = remapClipToAvatarBones(stripRootTranslation(idleRaw),  avatarRoot, "Idle");
    const walk  = remapClipToAvatarBones(stripRootTranslation(walkRaw),  avatarRoot, "Walk");
    const run   = remapClipToAvatarBones(stripRootTranslation(runRaw),   avatarRoot, "Run");
    const jump  = remapClipToAvatarBones(stripRootTranslation(jumpRaw),  avatarRoot, "Jump");
    const samba = remapClipToAvatarBones(stripRootTranslation(sambaRaw), avatarRoot, "Samba");
    const rumba = remapClipToAvatarBones(stripRootTranslation(rumbaRaw), avatarRoot, "Rumba");
    const salsa = remapClipToAvatarBones(stripRootTranslation(salsaRaw), avatarRoot, "Salsa");

    actions.Samba = mixer.clipAction(samba);
    actions.Rumba = mixer.clipAction(rumba);
    actions.Salsa = mixer.clipAction(salsa);

    for (const k of ["Samba","Rumba","Salsa"]) {
      actions[k].loop = THREE.LoopOnce;
      actions[k].clampWhenFinished = true;
    }

    actions.Idle = mixer.clipAction(idle);
    actions.Walk = mixer.clipAction(walk);
    actions.Jump = mixer.clipAction(jump);

    mixer.addEventListener("finished", (e) => {
      if (e.action === actions.Jump) jumpAnimDone = true;
      if (danceActive && e.action === actions[danceActive]) danceActive = null;
    });

    if ((run.tracks?.length || 0) < MIN_TRACKS_FOR_RUN) {
      actions.Run = mixer.clipAction(walk);
      actions.Run.setEffectiveTimeScale(1.35);
    } else {
      actions.Run = mixer.clipAction(run);
      actions.Run.setEffectiveTimeScale(1.08);
    }

    actions.Walk.setEffectiveTimeScale(1.0);
    actions.Idle.setEffectiveTimeScale(1.0);

    actions.Jump.loop = THREE.LoopOnce;
    actions.Jump.clampWhenFinished = true;

    playAction("Idle", 0.0);
  }

  setupAvatarAndAnims().catch((e) => console.error("Avatar/anims failed:", e));

  // ====== Audio (procedural wind + footsteps) ======
  let audioCtx = null;
  let master = null;
  let windGain = null;
  
  function ensureAudio(){
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  
    master = audioCtx.createGain();
    master.gain.value = 0.9;
    master.connect(audioCtx.destination);
  
    // --- Wind: looped noise -> bandpass -> lowpass ---
    const bufferSize = (audioCtx.sampleRate * 2) | 0;
    const noiseBuf = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = noiseBuf.getChannelData(0);
    for (let i=0;i<bufferSize;i++){
      data[i] = (Math.random()*2-1) * 0.45;
    }
  
    const windSrc = audioCtx.createBufferSource();
    windSrc.buffer = noiseBuf;
    windSrc.loop = true;
  
    const bp = audioCtx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.value = 380;
    bp.Q.value = 0.8;
  
    const lp = audioCtx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.value = 1400;
  
    windGain = audioCtx.createGain();
    windGain.gain.value = 0.06; // subtle base
  
    windSrc.connect(bp);
    bp.connect(lp);
    lp.connect(windGain);
    windGain.connect(master);
    windSrc.start();
  }
  
  function setWindStrength(v){ // 0..1
    if (!windGain || !audioCtx) return;
    // smooth
    const t = audioCtx.currentTime;
    const target = 0.03 + 0.12 * v;
    windGain.gain.cancelScheduledValues(t);
    windGain.gain.setTargetAtTime(target, t, 0.12);
  }
  
  function playFootstep(strength=1){
    if (!audioCtx) return;
    const t = audioCtx.currentTime;
  
    const osc = audioCtx.createOscillator();
    osc.type = "sine";
    osc.frequency.setValueAtTime(120, t);
    osc.frequency.exponentialRampToValueAtTime(70, t + 0.08);
  
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.08 * strength, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);
  
    // grit noise
    const nSize = (audioCtx.sampleRate * 0.12)|0;
    const nb = audioCtx.createBuffer(1, nSize, audioCtx.sampleRate);
    const nd = nb.getChannelData(0);
    for (let i=0;i<nSize;i++){
      nd[i] = (Math.random()*2-1) * (1 - i/nSize);
    }
    const ns = audioCtx.createBufferSource();
    ns.buffer = nb;
  
    const hp = audioCtx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.value = 700;
  
    const ng = audioCtx.createGain();
    ng.gain.setValueAtTime(0.0001, t);
    ng.gain.exponentialRampToValueAtTime(0.05 * strength, t + 0.01);
    ng.gain.exponentialRampToValueAtTime(0.0001, t + 0.09);
  
    osc.connect(g); g.connect(master);
    ns.connect(hp); hp.connect(ng); ng.connect(master);
  
    osc.start(t); osc.stop(t + 0.14);
    ns.start(t);  ns.stop(t + 0.12);
  }
  
  window.addEventListener("pointerdown", async () => {
    ensureAudio();
    if (audioCtx && audioCtx.state !== "running") await audioCtx.resume();
  }, { once: true });

  // ====== Movement + Jump ======
  const keys = new Set();
  let jumpRequested = false;

  const FOOT_OFFSET = 0;
  let visualGroundY = terrainHeight(player.position.x, player.position.z);
  playerVisual.position.y = visualGroundY + FOOT_OFFSET;

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    keys.add(k);

    if (k === "1") { danceActive = "Samba"; playAction("Samba", 0.08); }
    if (k === "2") { danceActive = "Rumba"; playAction("Rumba", 0.08); }
    if (k === "3") { danceActive = "Salsa"; playAction("Salsa", 0.08); }

    if (k === " " || k === "spacebar") jumpRequested = true;
  });
  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

  const clock = new THREE.Clock();
  const tmpVec = new THREE.Vector3();

  function clampToMap(pos) {
    const d = Math.hypot(pos.x, pos.z);
    if (d > MAP_RADIUS) {
      const s = MAP_RADIUS / d;
      pos.x *= s;
      pos.z *= s;
    }
  }

  let isJumping = false;
  let yVel = 0;
  let stepTimer = 0;

  function startJump() {
    if (isJumping) return;
    isJumping = true;
    jumpAnimDone = false;
    yVel = JUMP_VEL;
    playAction("Jump", 0.06);
  }

  function updatePlayer(dt){
    if (jumpRequested && !isJumping) { jumpRequested = false; startJump(); }
    else if (jumpRequested) { jumpRequested = false; }

    const isRunning = keys.has("shift");
    const speed = isRunning ? RUN_SPEED : WALK_SPEED;

    let forward = 0, right = 0;
    if (keys.has("w")) forward -= 1;
    if (keys.has("s")) forward += 1;
    if (keys.has("d")) right += 1;
    if (keys.has("a")) right -= 1;

    const az = controls.getAzimuthalAngle();
    const dirF = new THREE.Vector3(Math.sin(az), 0, Math.cos(az));
    const dirR = new THREE.Vector3(Math.sin(az + Math.PI/2), 0, Math.cos(az + Math.PI/2));

    tmpVec.set(0,0,0);
    tmpVec.addScaledVector(dirF, forward);
    tmpVec.addScaledVector(dirR, right);

    const isMoving = tmpVec.lengthSq() > 0;

    if (isMoving) {
      const mv = tmpVec.clone().normalize();
      const targetYaw = Math.atan2(mv.x, mv.z);
      let d = targetYaw - player.rotation.y;
      d = Math.atan2(Math.sin(d), Math.cos(d));
      player.rotation.y += d * Math.min(1, dt * 10);
    }

    if (isMoving) {
      const control = isJumping ? AIR_CONTROL : 1.0;
      tmpVec.normalize().multiplyScalar(speed * control * dt);
      player.position.add(tmpVec);
      clampToMap(player.position);
    }

    if (isMoving && danceActive) {
      danceActive = null;
      if (currentAction) currentAction.fadeOut(0.08);
    }

    const targetGround = terrainHeight(player.position.x, player.position.z);
    visualGroundY = THREE.MathUtils.lerp(visualGroundY, targetGround, 1 - Math.pow(0.0001, dt));

    if (isJumping) {
      yVel += GRAVITY * dt;
      playerVisual.position.y += yVel * dt;

      const landingY = visualGroundY + FOOT_OFFSET;
      if (playerVisual.position.y <= landingY) {
        playerVisual.position.y = landingY;
        yVel = 0;
        if (jumpAnimDone) isJumping = false;
      }
    } else {
      playerVisual.position.y = visualGroundY + FOOT_OFFSET;
    }

    if (actions.Idle) {
      if (danceActive) playAction(danceActive, 0.06);
      else if (isJumping) playAction("Jump", 0.05);
      else if (isMoving && isRunning) playAction("Run", 0.12);
      else if (isMoving) playAction("Walk", 0.14);
      else playAction("Idle", 0.18);
    }

    if (!isJumping && isMoving) {
      const interval = isRunning ? STEP_INTERVAL_RUN : STEP_INTERVAL_WALK;
      stepTimer -= dt;
      if (stepTimer <= 0) {
        stepTimer = interval;
        playFootstep(isRunning ? 1.0 : 0.7);
      }
    } else {
      stepTimer = Math.min(stepTimer, 0.08);
    }
  }

  function updateCamera(dt){
    const target = player.position.clone();
    target.y = playerVisual.position.y + LOOK_HEIGHT;
    controls.target.lerp(target, 1 - Math.pow(0.001, dt));
    controls.update();
  }

  function checkMemoryTriggers(){
    let closest = null;
    let closestDist = Infinity;

    for (const s of spots) {
      const d = player.position.distanceTo(s.mem.pos);
      if (d < closestDist) { closestDist = d; closest = s; }
    }

    if (closest && closestDist <= 2.1) {
      if (activeSpotId !== closest.mem.id) openMemory(closest.mem);
    }
  }

  function animate(){
    requestAnimationFrame(animate);
    const dt = Math.min(clock.getDelta(), 0.033);
  
    updatePlayer(dt);
  
    const moving = keys.has("w") || keys.has("a") || keys.has("s") || keys.has("d");
  
    // wind audio
    const windBase = 0.45 + 0.35 * Math.sin(clock.elapsedTime * 0.15);
    const windMove = moving ? 0.35 : 0.0;
    setWindStrength(THREE.MathUtils.clamp(windBase + windMove, 0, 1));
  
    updateCamera(dt);
    updateClouds(dt, clock.elapsedTime);
  
    // grass uniforms
    grassField.mat.uniforms.uTime.value = clock.elapsedTime;
    grassField.mat.uniforms.uPlayerPos.value.copy(player.position);
    grassField.mat.uniforms.uWindStrength.value = moving ? 1.15 : 0.85;
  
    const t = clock.elapsedTime;
    for (const s of spots) {
      s.ring.rotation.z = t * 0.7;
      s.marker.position.y = 1.35 + Math.sin(t * 2.2 + s.mem.pos.x) * 0.08;
    }
  
    if (mixer) mixer.update(dt);
    checkMemoryTriggers();
  
    renderer.render(scene, camera);
  }
  animate();
  
  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
