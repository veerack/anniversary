<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Our 1 Year</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#05060a; }
    #app { position:fixed; inset:0; }

    #hud{
      position: fixed;
      left: 12px; top: 12px;
      color: rgba(255,255,255,0.9);
      font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      z-index: 5;
      user-select:none;
      background: rgba(0,0,0,0.35);
      padding: 10px 12px;
      border-radius: 12px;
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.12);
      max-width: 360px;
    }
    #hint { opacity:0.85; margin-top:6px; font-size:13px; }

    /* Center memory popup */
    #panel{
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: min(520px, calc(100vw - 28px));
      max-height: min(60vh, 520px);
      overflow:auto;
      z-index: 6;
      background: rgba(10,12,18,0.82);
      color: rgba(255,255,255,0.92);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 18px;
      padding: 14px 14px 12px;
      backdrop-filter: blur(10px);
      display:none;
    }
    #panel h2 { margin: 2px 0 8px; font-size: 18px; }
    #panel p { margin: 0 0 10px; font-size: 14px; opacity:0.92; }
    #closeBtn{
      position:absolute;
      top:10px; right:10px;
      background: rgba(255,255,255,0.12);
      color:#fff; border:1px solid rgba(255,255,255,0.14);
      border-radius: 10px; padding: 6px 10px;
      cursor:pointer;
    }

    #footer{
      position: fixed;
      left: 12px; bottom: 12px;
      z-index: 5;
      color: rgba(255,255,255,0.65);
      font: 12px system-ui;
      background: rgba(0,0,0,0.25);
      padding: 6px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      user-select:none;
    }
    code { color: #d7e3ff; }
  </style>
</head>
<body>
  <div id="app"></div>

  <div id="hud">
    <div><strong>Controls:</strong> WASD move Â· Shift run Â· Space jump Â· Mouse drag rotate</div>
    <div id="hint">Tip: edit <code>MEMORIES</code> in the code.</div>
  </div>

  <div id="panel">
    <button id="closeBtn">Close</button>
    <h2 id="panelTitle"></h2>
    <p id="panelText"></p>
    <div id="panelExtra"></div>
  </div>

  <div id="footer">Built for us ðŸ’™</div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { FBXLoader } from "three/addons/loaders/FBXLoader.js";

    // ====== EDIT THESE ======
    const AVATAR_URL = "https://models.readyplayer.me/695c48e31c1817592c4ec48b.glb";

    const ANIMS = {
      Idle: "/anniversary/assets/anim/Idle.fbx",
      Walk: "/anniversary/assets/anim/Walk.fbx",
      Run:  "/anniversary/assets/anim/Run.fbx",
      Jump: "/anniversary/assets/anim/Jump.fbx",
    };

    const MEMORIES = [
      { id:"first-meet",  title:"How we met",         text:"Write a short story here.", pos:new THREE.Vector3(-6,0,-4) },
      { id:"first-date",  title:"First date",         text:"Where did you go? One detail you remember.", pos:new THREE.Vector3(6,0,-2) },
      { id:"moment",      title:"The moment I knew",  text:"One moment that made it clear sheâ€™s your person.", pos:new THREE.Vector3(-2,0,7) },
      { id:"future",      title:"Whatâ€™s next",        text:"Something youâ€™re excited to do together this year.", pos:new THREE.Vector3(7,0,7) },
    ];

    // ====== Helpers: bone name normalization ======
    function normalizeBoneName(name){
      // Common cases:
      // Mixamo: mixamorigHips, mixamorigSpine, ...
      // RPM:    Hips, Spine, ...
      return name
        .replace(/^mixamorig/i, "")
        .replace(/^Armature\|/i, "")
        .replace(/^Root\|/i, "");
    }

    function buildBoneMap(root){
      const map = new Map();
      root.traverse((o) => {
        if (o.isBone) map.set(normalizeBoneName(o.name), o);
      });
      return map;
    }

    function retargetMixamoClip(clip, sourceRoot, targetRoot){
      const src = buildBoneMap(sourceRoot);
      const dst = buildBoneMap(targetRoot);
      const tracks = [];

      for (const t of clip.tracks){
        const [rawNode, prop] = t.name.split(".");
        const node = normalizeBoneName(rawNode);

        const srcBone = src.get(node);
        const dstBone = dst.get(node);
        if (!srcBone || !dstBone) continue;

        const times = t.times.slice();
        const values = t.values.slice();

        const trackName = `${dstBone.name}.${prop}`;

        if (t.ValueTypeName === "quaternion"){
          tracks.push(new THREE.QuaternionKeyframeTrack(trackName, times, values));
        } else if (t.ValueTypeName === "vector"){
          tracks.push(new THREE.VectorKeyframeTrack(trackName, times, values));
        }
      }

      return new THREE.AnimationClip(clip.name, clip.duration, tracks);
    }

    // ====== Scene setup ======
    const app = document.getElementById("app");
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x05060a, 10, 55);

    const camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.1, 200);
    camera.position.set(0, 10, 14);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    app.appendChild(renderer.domElement);

    // Lights
    scene.add(new THREE.HemisphereLight(0xaecbff, 0x1a1d2b, 0.95));
    const dir = new THREE.DirectionalLight(0xffffff, 1.1);
    dir.position.set(12, 18, 10);
    dir.castShadow = true;
    dir.shadow.mapSize.set(1024, 1024);
    dir.shadow.camera.left = -25;
    dir.shadow.camera.right = 25;
    dir.shadow.camera.top = 25;
    dir.shadow.camera.bottom = -25;
    scene.add(dir);

    // Ground + walls
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(40, 40),
      new THREE.MeshStandardMaterial({ color: 0x0b1020, roughness:0.95, metalness:0 })
    );
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    const wallMat = new THREE.MeshStandardMaterial({ color: 0x111634, roughness: 0.9 });
    function wall(w,h,d,x,y,z){
      const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), wallMat);
      m.position.set(x,y,z);
      m.castShadow = true; m.receiveShadow = true;
      scene.add(m);
      return m;
    }
    wall(40, 2.5, 0.8, 0, 1.25, -20);
    wall(40, 2.5, 0.8, 0, 1.25, 20);
    wall(0.8, 2.5, 40, -20, 1.25, 0);
    wall(0.8, 2.5, 40, 20, 1.25, 0);

    // Some props
    const propMat = new THREE.MeshStandardMaterial({ color: 0x1a2250, roughness: 0.8 });
    function pillar(x,z){
      const p = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.8,3.2,18), propMat);
      p.position.set(x,1.6,z);
      p.castShadow = true; p.receiveShadow = true;
      scene.add(p);
    }
    pillar(-10,10); pillar(10,-10); pillar(0,0);

    // ====== Player + Avatar ======
    const player = new THREE.Group();
    player.position.set(0,0,8);
    scene.add(player);

    // Temporary capsule (hidden after avatar loads)
    const tempCapsule = new THREE.Mesh(
      new THREE.CylinderGeometry(0.55, 0.55, 1.8, 16),
      new THREE.MeshStandardMaterial({ color:0x9fb6ff, roughness:0.35, metalness:0.1 })
    );
    tempCapsule.castShadow = true;
    tempCapsule.position.y = 1.0;
    player.add(tempCapsule);

    const gltfLoader = new GLTFLoader();
    const fbxLoader  = new FBXLoader();

    let avatarRoot = null;
    let mixer = null;
    const actions = {};
    let currentAction = null;

    function playAction(name, fade=0.18){
      const next = actions[name];
      if (!next) return;
      if (currentAction === next) return;

      if (currentAction) currentAction.fadeOut(fade);
      currentAction = next;
      currentAction.reset().fadeIn(fade).play();
    }

    async function loadFBXAnim(name, url, mixamoSkeletonRoot){
      return new Promise((resolve, reject) => {
        fbxLoader.load(url, (fbx) => {
          const clip = fbx.animations && fbx.animations[0];
          if (!clip) return reject(new Error(`No animation in ${url}`));
          const retargeted = retargetMixamoClip(clip, fbx, avatarRoot);

          const action = mixer.clipAction(retargeted);
          action.enabled = true;
          action.clampWhenFinished = true;
          action.loop = (name === "Jump") ? THREE.LoopOnce : THREE.LoopRepeat;

          actions[name] = action;
          resolve();
        }, undefined, reject);
      });
    }

    async function loadAvatarAndAnims(){
      gltfLoader.load(AVATAR_URL, async (gltf) => {
        avatarRoot = gltf.scene;

        avatarRoot.traverse((o) => {
          if (o.isMesh) { o.castShadow = true; o.receiveShadow = true; }
        });

        // tweak scale/height if needed
        avatarRoot.scale.setScalar(1.0);

        player.add(avatarRoot);
        tempCapsule.visible = false;

        mixer = new THREE.AnimationMixer(avatarRoot);

        try{
          await Promise.all([
            loadFBXAnim("Idle", ANIMS.Idle),
            loadFBXAnim("Walk", ANIMS.Walk),
            loadFBXAnim("Run",  ANIMS.Run),
            loadFBXAnim("Jump", ANIMS.Jump),
          ]);
          playAction("Idle", 0.0);
          console.log("Animations loaded:", Object.keys(actions));
        } catch(e){
          console.error("Animation load/retarget failed:", e);
        }

      }, undefined, (e) => console.error("Avatar load failed:", e));
    }

    loadAvatarAndAnims();

    // ====== Camera controls ======
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.minDistance = 6;
    controls.maxDistance = 24;
    controls.maxPolarAngle = Math.PI * 0.49;
    controls.target.copy(player.position).add(new THREE.Vector3(0, 1.2, 0));

    // ====== Memory spots ======
    const spots = [];
    const spotGeo = new THREE.TorusGeometry(1.0, 0.12, 16, 50);
    const glowMat = new THREE.MeshStandardMaterial({
      color: 0x7da6ff,
      emissive: 0x3b66ff,
      emissiveIntensity: 1.6,
      roughness: 0.2,
      metalness: 0.25
    });

    for (const mem of MEMORIES) {
      const ring = new THREE.Mesh(spotGeo, glowMat.clone());
      ring.rotation.x = Math.PI / 2;
      ring.position.copy(mem.pos);
      ring.position.y = 0.12;
      ring.receiveShadow = true;
      scene.add(ring);

      const marker = new THREE.Mesh(
        new THREE.SphereGeometry(0.18, 18, 18),
        new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x7da6ff, emissiveIntensity: 1.2 })
      );
      marker.position.copy(mem.pos);
      marker.position.y = 1.35;
      marker.castShadow = true;
      scene.add(marker);

      spots.push({ mem, ring, marker });
    }

    // ====== UI panel ======
    const panel = document.getElementById("panel");
    const panelTitle = document.getElementById("panelTitle");
    const panelText = document.getElementById("panelText");
    document.getElementById("closeBtn").onclick = () => {
      panel.style.display = "none";
      activeSpotId = null;
    };

    let activeSpotId = null;
    function openMemory(mem){
      activeSpotId = mem.id;
      panelTitle.textContent = mem.title;
      panelText.textContent = mem.text;
      panel.style.display = "block";
    }

    // ====== Movement + animation switching ======
    const keys = new Set();
    let isJumping = false;
    let jumpCooldown = 0;

    window.addEventListener("keydown", (e) => {
      const k = e.key.toLowerCase();
      keys.add(k);

      if ((k === " " || k === "spacebar") && !isJumping && jumpCooldown <= 0) {
        isJumping = true;
        jumpCooldown = 0.65;
        playAction("Jump", 0.05);
      }
    });
    window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

    const clock = new THREE.Clock();
    const tmpVec = new THREE.Vector3();

    function clampToMap(pos) {
      pos.x = Math.max(-18.5, Math.min(18.5, pos.x));
      pos.z = Math.max(-18.5, Math.min(18.5, pos.z));
    }

    function updatePlayer(dt){
      const isRunning = keys.has("shift");
      const speed = isRunning ? 6.2 : 4.2;

      let forward = 0, right = 0;
      if (keys.has("w")) forward += 1;
      if (keys.has("s")) forward -= 1;
      if (keys.has("d")) right += 1;
      if (keys.has("a")) right -= 1;

      const yaw = controls.getAzimuthalAngle();

      // FIX: W forward, S backward
      const dirF = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw)).normalize();
      const dirR = new THREE.Vector3(dirF.z, 0, -dirF.x).normalize();

      tmpVec.set(0,0,0);
      tmpVec.addScaledVector(dirF, forward);
      tmpVec.addScaledVector(dirR, right);

      const isMoving = tmpVec.lengthSq() > 0;

      if (isMoving && !isJumping) {
        tmpVec.normalize().multiplyScalar(speed * dt);
        player.position.add(tmpVec);
        clampToMap(player.position);

        const look = player.position.clone().add(tmpVec.clone().normalize());
        player.lookAt(look.x, player.position.y, look.z);
      }

      controls.target.copy(player.position).add(new THREE.Vector3(0, 1.2, 0));

      if (Object.keys(actions).length) {
        if (isJumping) playAction("Jump");
        else if (isMoving && isRunning) playAction("Run");
        else if (isMoving) playAction("Walk");
        else playAction("Idle");
      }
    }

    function checkMemoryTriggers(){
      let closest = null;
      let closestDist = Infinity;

      for (const s of spots) {
        const d = player.position.distanceTo(s.mem.pos);
        if (d < closestDist) { closestDist = d; closest = s; }
      }

      if (closest && closestDist <= 2.1) {
        if (activeSpotId !== closest.mem.id) openMemory(closest.mem);
      }
    }

    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.033);

      updatePlayer(dt);

      if (jumpCooldown > 0) {
        jumpCooldown -= dt;
        if (jumpCooldown <= 0) isJumping = false;
      }

      const t = clock.elapsedTime;
      for (const s of spots) {
        s.ring.rotation.z = t * 0.7;
        s.marker.position.y = 1.35 + Math.sin(t * 2.2 + s.mem.pos.x) * 0.08;
      }

      if (mixer) mixer.update(dt);

      checkMemoryTriggers();
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
