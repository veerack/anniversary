<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Our 1 Year</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#05060a; }
    #app { position:fixed; inset:0; }

    #hud{
      position: fixed;
      left: 12px; top: 12px;
      color: rgba(255,255,255,0.9);
      font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      z-index: 5;
      user-select:none;
      background: rgba(0,0,0,0.35);
      padding: 10px 12px;
      border-radius: 12px;
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.12);
      max-width: 380px;
    }
    #hint { opacity:0.85; margin-top:6px; font-size:13px; }

    /* Center memory popup */
    #panel{
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: min(520px, calc(100vw - 28px));
      max-height: min(60vh, 520px);
      overflow:auto;
      z-index: 6;
      background: rgba(10,12,18,0.86);
      color: rgba(255,255,255,0.92);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 18px;
      padding: 14px 14px 12px;
      backdrop-filter: blur(10px);
      display:none;
    }
    #panel h2 { margin: 2px 0 8px; font-size: 18px; }
    #panel p { margin: 0 0 10px; font-size: 14px; opacity:0.92; }
    #closeBtn{
      position:absolute;
      top:10px; right:10px;
      background: rgba(255,255,255,0.12);
      color:#fff; border:1px solid rgba(255,255,255,0.14);
      border-radius: 10px; padding: 6px 10px;
      cursor:pointer;
    }

    #footer{
      position: fixed;
      left: 12px; bottom: 12px;
      z-index: 5;
      color: rgba(255,255,255,0.65);
      font: 12px system-ui;
      background: rgba(0,0,0,0.25);
      padding: 6px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      user-select:none;
    }
    code { color: #d7e3ff; }
  </style>
</head>
<body>
  <div id="app"></div>

  <div id="hud">
    <div><strong>Controls:</strong> WASD move Â· Shift run Â· Space jump Â· Mouse drag rotate</div>
    <div id="hint">Tip: edit <code>MEMORIES</code> in the code.</div>
  </div>

  <div id="panel">
    <button id="closeBtn">Close</button>
    <h2 id="panelTitle"></h2>
    <p id="panelText"></p>
  </div>

  <div id="footer">Built for us ðŸ’™</div>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

<script type="module">
  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { FBXLoader } from "three/addons/loaders/FBXLoader.js";
  import { Sky } from "three/addons/objects/Sky.js";

  // ====== EDIT THESE ======
  const AVATAR_URL = "https://models.readyplayer.me/695c48e31c1817592c4ec48b.glb";
  const ANIMS = {
    Idle: "assets/anim/Idle.fbx",
    Walk: "assets/anim/Walk.fbx",
    Run:  "assets/anim/Run.fbx",
    Jump: "assets/anim/Jump.fbx",
    Samba: "assets/anim/Samba.fbx",
    Rumba: "assets/anim/Rumba.fbx",
    Salsa: "assets/anim/Salsa.fbx",
  };

  const MEMORIES = [
    { id:"first-meet", title:"How we met", text:"Write a short story here.", pos:new THREE.Vector3(-6,0,-4) },
    { id:"first-date", title:"First date", text:"Where did you go? One detail you remember.", pos:new THREE.Vector3(6,0,-2) },
    { id:"moment", title:"The moment I knew", text:"One moment that made it clear sheâ€™s your person.", pos:new THREE.Vector3(-2,0,7) },
    { id:"future", title:"Whatâ€™s next", text:"Something youâ€™re excited to do together this year.", pos:new THREE.Vector3(7,0,7) },
  ];

  // ====== Tuning ======
  const WALK_SPEED = 2.6;
  const RUN_SPEED  = 8.0;
  const AIR_CONTROL = 0.65;

  const GRAVITY = -18.0;
  const JUMP_VEL = 6.4;

  const LOOK_HEIGHT = 1.45;
  const MIN_TRACKS_FOR_RUN = 40;

  // footsteps timing
  const STEP_INTERVAL_WALK = 0.42;
  const STEP_INTERVAL_RUN  = 0.28;

  const MAP_RADIUS = 55;
  const TERRAIN_SIZE = 120;
  const TERRAIN_SEG = 140; // 120..200 ok
  let grassWindAccum = 0;

  // ====== Small utilities ======

  function hash2(x, z) {
    return (Math.sin(x * 127.1 + z * 311.7) * 43758.5453123) % 1;
  }
  
  function terrainHeight(x, z) {
    // soft hills + small noise
    const h1 = Math.sin(x * 0.06) * 1.2 + Math.cos(z * 0.05) * 1.1;
    const h2 = Math.sin((x + z) * 0.035) * 1.6;
    const n  = (hash2(x * 0.35, z * 0.35) - 0.5) * 0.35;
    let h = (h1 + h2) * 0.8 + n;
  
    // Flatten a â€œwalking areaâ€ near center (nice playable)
    const d = Math.hypot(x, z);
    const flat = THREE.MathUtils.smoothstep(d, 0, 18);
    h *= (1.0 - flat * 0.75);
  
    return h;
  }
  
  function normalizeKey(name) {
    return String(name || "")
      .replace(/^Armature\|/i, "")
      .replace(/^mixamorig/i, "")
      .replace(/[^a-z0-9]/gi, "")
      .toLowerCase();
  }

  function buildBoneKeyToNameMap(root) {
    const map = new Map();
    root.traverse((o) => {
      if (!o.isBone) return;
      const key = normalizeKey(o.name);
      if (key && !map.has(key)) map.set(key, o.name);
    });
    return map;
  }

  function stripRootTranslation(clip) {
    const tracks = clip.tracks.filter((t) => !t.name.toLowerCase().endsWith(".position"));
    return new THREE.AnimationClip(clip.name, clip.duration, tracks);
  }

  function remapClipToAvatarBones(clip, avatarRoot, debugLabel) {
    const boneMap = buildBoneKeyToNameMap(avatarRoot);
    const outTracks = [];
    let mapped = 0;

    for (const tr of clip.tracks) {
      const parts = tr.name.split(".");
      if (parts.length < 2) continue;

      const srcNode = parts[0];
      const prop = parts.slice(1).join(".");
      const key = normalizeKey(srcNode);
      const dstBoneName = boneMap.get(key);
      if (!dstBoneName) continue;

      const dstTrackName = `${dstBoneName}.${prop}`;
      const times = tr.times.slice();
      const values = tr.values.slice();

      if (tr.ValueTypeName === "quaternion") {
        outTracks.push(new THREE.QuaternionKeyframeTrack(dstTrackName, times, values));
        mapped++;
      } else if (tr.ValueTypeName === "vector") {
        outTracks.push(new THREE.VectorKeyframeTrack(dstTrackName, times, values));
        mapped++;
      }
    }

    const out = new THREE.AnimationClip(clip.name || debugLabel, clip.duration, outTracks);
    out.userData = { mappedTracks: mapped, label: debugLabel };
    return out;
  }

  function forceMeshVisible(root) {
    root.traverse((o) => {
      if (!o.isMesh) return;
      o.frustumCulled = false;
      o.visible = true;
      o.castShadow = true;
      o.receiveShadow = true;

      const mats = Array.isArray(o.material) ? o.material : [o.material];
      for (const m of mats) {
        if (!m) continue;
        m.depthWrite = true;
        m.depthTest = true;
        m.needsUpdate = true;
      }
    });
  }

  // ====== Scene setup ======
  const app = document.getElementById("app");
  const scene = new THREE.Scene();
  scene.environment = null;

  // renderer (better lighting + reflections)
  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.physicallyCorrectLights = true;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 0.55; // was ~0.88 â†’ too bright
  renderer.outputColorSpace = THREE.SRGBColorSpace;

  app.appendChild(renderer.domElement);

  const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 250);
  camera.position.set(0, 4, 6);

  // ====== Sky + Sun/Moon + Env reflections ======
  const sky = new Sky();
  sky.scale.setScalar(450000);
  scene.add(sky);

  const skyU = sky.material.uniforms;
  skyU["turbidity"].value = 4;
  skyU["rayleigh"].value = 2.0;
  skyU["mieCoefficient"].value = 0.002;
  skyU["mieDirectionalG"].value = 0.85;

  const sunLight = new THREE.DirectionalLight(0xffffff, 2.2);
  sunLight.castShadow = true;
  
  sunLight.shadow.mapSize.set(4096, 4096);
  
  const SHADOW_BOX = 70;
  sunLight.shadow.camera.far = 220;
  sunLight.shadow.camera.near = 1;
  sunLight.shadow.camera.left   = -SHADOW_BOX;
  sunLight.shadow.camera.right  =  SHADOW_BOX;
  sunLight.shadow.camera.top    =  SHADOW_BOX;
  sunLight.shadow.camera.bottom = -SHADOW_BOX;
  
  sunLight.shadow.bias = -0.00025;
  sunLight.shadow.normalBias = 0.02;
  
  scene.add(sunLight);

  const sunTarget = new THREE.Object3D();
  scene.add(sunTarget);
  sunLight.target = sunTarget;

  const moonLight = new THREE.DirectionalLight(0xbfd6ff, 0.35);
  scene.add(moonLight);

  const hemi = new THREE.HemisphereLight(0xbfdcff, 0x0b1218, 0.55);
  scene.add(hemi);
  
  scene.add(new THREE.AmbientLight(0xffffff, 0.015));

  const pmrem = new THREE.PMREMGenerator(renderer);

  // simple day-night progression (slow)
  let skyTime = 0.12; // [0..1) 0.25-ish = day, 0.75-ish = night

  let envRT = null;
  let envRefreshTimer = 3.0;

  function updateSunForShadows(){
    const sunDir = new THREE.Vector3(0.6, 1.0, 0.35).normalize();
    sunLight.position.copy(player.position).addScaledVector(sunDir, 120);
  
    sunTarget.position.copy(player.position);
    sunTarget.updateMatrixWorld();
  }
  
  function updateSkyAndEnv(dt){
    skyTime = (skyTime + dt * 0.004) % 1;
  
    const theta = Math.PI * 2 * skyTime;
    const elevation = Math.sin(theta) * 35;
    const azimuth = 180 + Math.cos(theta) * 35;
  
    const phi = THREE.MathUtils.degToRad(90 - elevation);
    const th  = THREE.MathUtils.degToRad(azimuth);
  
    const sunPos = new THREE.Vector3().setFromSphericalCoords(1, phi, th);
    sky.material.uniforms.sunPosition.value.copy(sunPos);
  
    // keep only sky sun position for visuals
    moonLight.position.copy(sunPos).multiplyScalar(-120);
  
    const dayFactor = THREE.MathUtils.clamp((elevation + 6) / 18, 0, 1);
    sunLight.intensity = 1.8 * dayFactor;  // was 2.6*
    moonLight.intensity = 0.18 * (1 - dayFactor);
  
    // fog + background
    const dayFog = new THREE.Color(0xbad8ff);
    const nightFog = new THREE.Color(0x05060a);
    const fogCol = nightFog.clone().lerp(dayFog, dayFactor);
  
    if (!scene.fog) scene.fog = new THREE.Fog(fogCol, 18, 95);
    scene.fog.color.copy(fogCol);
    renderer.setClearColor(fogCol, 1);
  
    // âœ… refresh environment only sometimes (every ~1.5s)
    envRefreshTimer -= dt;
    if (envRefreshTimer <= 0) {
      envRefreshTimer = 1.5;
      if (envRT) envRT.dispose();
      envRT = pmrem.fromScene(sky);
      scene.environment = envRT.texture;
    }
    updateSunForShadows();
  }

  // ====== Clouds (billboards with procedural alpha texture) ======
  function makeCloudTexture() {
    const c = document.createElement("canvas");
    c.width = 256; c.height = 128;
    const g = c.getContext("2d");

    g.clearRect(0,0,c.width,c.height);

    // soft blobs
    for (let i=0;i<26;i++){
      const x = Math.random()*c.width;
      const y = 20 + Math.random()*70;
      const r = 18 + Math.random()*40;

      const grd = g.createRadialGradient(x,y, r*0.1, x,y, r);
      grd.addColorStop(0, "rgba(255,255,255,0.35)");
      grd.addColorStop(1, "rgba(255,255,255,0)");
      g.fillStyle = grd;
      g.beginPath();
      g.arc(x,y,r,0,Math.PI*2);
      g.fill();
    }

    const tex = new THREE.CanvasTexture(c);
    tex.colorSpace = THREE.SRGBColorSpace;
    tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
    tex.needsUpdate = true;
    return tex;
  }

  const clouds = new THREE.Group();
  scene.add(clouds);

  const cloudTex = makeCloudTexture();
  const cloudMat = new THREE.MeshStandardMaterial({
    map: cloudTex,
    transparent: true,
    opacity: 0.65,
    depthWrite: false,
    roughness: 1.0,
    metalness: 0.0,
    emissive: new THREE.Color(0x0),
  });

  for (let i=0;i<18;i++){
    const w = 18 + Math.random()*22;
    const h = w * (0.45 + Math.random()*0.2);
    const m = new THREE.Mesh(new THREE.PlaneGeometry(w,h), cloudMat);
    m.position.set((Math.random()-0.5)*140, 26 + Math.random()*18, (Math.random()-0.5)*140);
    m.rotation.y = Math.random()*Math.PI*2;
    m.renderOrder = 10;
    clouds.add(m);
  }

  function updateClouds(dt){
    // drift clouds slowly
    for (const m of clouds.children){
      m.position.x += dt * 0.45;
      if (m.position.x > 80) m.position.x = -80;
      // face camera (billboard)
      m.lookAt(camera.position.x, m.position.y, camera.position.z);
    }
  }

  // ====== Proper-ish grass (color + normal + roughness maps) ======
  function makeGrassMaps() {
    const size = 512;

    // albedo
    const c0 = document.createElement("canvas");
    c0.width = c0.height = size;
    const g0 = c0.getContext("2d");

    g0.fillStyle = "#0b2411";
    g0.fillRect(0,0,size,size);

    for (let i=0;i<22000;i++){
      const x = (Math.random()*size)|0;
      const y = (Math.random()*size)|0;
      const v = 50 + (Math.random()*90)|0;
      const r = 10 + (Math.random()*20)|0;
      g0.fillStyle = `rgb(${r},${v},${20})`;
      g0.fillRect(x,y,1,1);
    }

    // little blades strokes
    g0.globalAlpha = 0.35;
    for (let i=0;i<4500;i++){
      const x = Math.random()*size;
      const y = Math.random()*size;
      const len = 2 + Math.random()*6;
      const ang = Math.random()*Math.PI*2;
      g0.strokeStyle = "rgba(160,255,190,0.20)";
      g0.lineWidth = 1;
      g0.beginPath();
      g0.moveTo(x,y);
      g0.lineTo(x + Math.cos(ang)*len, y + Math.sin(ang)*len);
      g0.stroke();
    }
    g0.globalAlpha = 1;

    // normal map (fake bumps)
    const cN = document.createElement("canvas");
    cN.width = cN.height = size;
    const gN = cN.getContext("2d");
    const imgN = gN.createImageData(size,size);

    function heightAt(x,y){
      // cheap pseudo height based on random dots using hashing
      const n = Math.sin(x*12.9898 + y*78.233) * 43758.5453;
      return n - Math.floor(n);
    }

    for (let y=0;y<size;y++){
      for (let x=0;x<size;x++){
        const hL = heightAt(x-1,y);
        const hR = heightAt(x+1,y);
        const hD = heightAt(x,y-1);
        const hU = heightAt(x,y+1);

        const dx = (hR - hL) * 1.2;
        const dy = (hU - hD) * 1.2;

        // normal = normalize([-dx, -dy, 1])
        let nx = -dx, ny = -dy, nz = 1.0;
        const inv = 1 / Math.hypot(nx,ny,nz);
        nx*=inv; ny*=inv; nz*=inv;

        const i = (y*size + x)*4;
        imgN.data[i+0] = ((nx*0.5+0.5)*255)|0;
        imgN.data[i+1] = ((ny*0.5+0.5)*255)|0;
        imgN.data[i+2] = ((nz*0.5+0.5)*255)|0;
        imgN.data[i+3] = 255;
      }
    }
    gN.putImageData(imgN,0,0);

    // roughness map (slight variation)
    const cR = document.createElement("canvas");
    cR.width = cR.height = size;
    const gR = cR.getContext("2d");
    const imgR = gR.createImageData(size,size);
    for (let y=0;y<size;y++){
      for (let x=0;x<size;x++){
        const h = heightAt(x,y);
        const r = (170 + h*70)|0; // 170..240
        const i = (y*size + x)*4;
        imgR.data[i+0] = r;
        imgR.data[i+1] = r;
        imgR.data[i+2] = r;
        imgR.data[i+3] = 255;
      }
    }
    gR.putImageData(imgR,0,0);

    const map = new THREE.CanvasTexture(c0);
    map.colorSpace = THREE.SRGBColorSpace;
    map.wrapS = map.wrapT = THREE.RepeatWrapping;

    const normalMap = new THREE.CanvasTexture(cN);
    normalMap.wrapS = normalMap.wrapT = THREE.RepeatWrapping;

    const roughnessMap = new THREE.CanvasTexture(cR);
    roughnessMap.wrapS = roughnessMap.wrapT = THREE.RepeatWrapping;

    return { map, normalMap, roughnessMap };
  }

  const { map:grassMap, normalMap:grassNormal, roughnessMap:grassRough } = makeGrassMaps();
  grassMap.repeat.set(14,14);
  grassNormal.repeat.set(14,14);
  grassRough.repeat.set(14,14);

  const terrainGeo = new THREE.PlaneGeometry(TERRAIN_SIZE, TERRAIN_SIZE, TERRAIN_SEG, TERRAIN_SEG);
  terrainGeo.rotateX(-Math.PI / 2);
  
  const posAttr = terrainGeo.attributes.position;
  for (let i = 0; i < posAttr.count; i++) {
    const x = posAttr.getX(i);
    const z = posAttr.getZ(i);
    const y = terrainHeight(x, z);
    posAttr.setY(i, y);
  }
  terrainGeo.computeVertexNormals();
  
  const terrainMat = new THREE.MeshStandardMaterial({
    color: 0x2b5a2d,
    roughness: 0.95,
    metalness: 0.0,
    envMapIntensity: 0.15, // keep low to avoid wash
  });
  
  const ground = new THREE.Mesh(terrainGeo, terrainMat);
  ground.receiveShadow = true;
  scene.add(ground);

  function placeOnTerrain(obj, x, z, yOffset = 0) {
    obj.position.set(x, terrainHeight(x, z) + yOffset, z);
  }
  
  function addRock(x, z, s = 1) {
    const g = new THREE.IcosahedronGeometry(0.9 * s, 1);
    const m = new THREE.MeshStandardMaterial({ color: 0x3a3f4a, roughness: 0.95, metalness: 0.0, envMapIntensity: 0.12 });
    const rock = new THREE.Mesh(g, m);
    rock.castShadow = true;
    rock.receiveShadow = true;
    placeOnTerrain(rock, x, z, 0.1);
    rock.rotation.y = Math.random() * Math.PI * 2;
    scene.add(rock);
  }
  
  function addTree(x, z, s = 1) {
    const trunk = new THREE.Mesh(
      new THREE.CylinderGeometry(0.15 * s, 0.22 * s, 2.2 * s, 10),
      new THREE.MeshStandardMaterial({ color: 0x4a2e1d, roughness: 1, metalness: 0 })
    );
    const crown = new THREE.Mesh(
      new THREE.SphereGeometry(1.1 * s, 14, 14),
      new THREE.MeshStandardMaterial({ color: 0x1e4a25, roughness: 1, metalness: 0 })
    );
    trunk.castShadow = crown.castShadow = true;
    trunk.receiveShadow = crown.receiveShadow = true;
  
    const tree = new THREE.Group();
    tree.add(trunk);
    crown.position.y = 1.5 * s;
    tree.add(crown);
  
    placeOnTerrain(tree, x, z, 0);
    trunk.position.y = 1.1 * s;
  
    scene.add(tree);
  }
  
  function scatterScene() {
    // Ring of trees near edges
    for (let i = 0; i < 70; i++) {
      const a = Math.random() * Math.PI * 2;
      const r = 30 + Math.random() * 22;
      const x = Math.cos(a) * r;
      const z = Math.sin(a) * r;
      addTree(x, z, 0.85 + Math.random() * 0.6);
    }
  
    // Rocks around
    for (let i = 0; i < 45; i++) {
      const x = (Math.random() - 0.5) * 90;
      const z = (Math.random() - 0.5) * 90;
      if (Math.hypot(x, z) < 16) continue;
      addRock(x, z, 0.6 + Math.random() * 1.3);
    }
  
    // Simple â€œpathâ€ discs (visual, not physics)
    const pathMat = new THREE.MeshStandardMaterial({ color: 0x3a3a2f, roughness: 1, metalness: 0 });
    for (let i = 0; i < 26; i++) {
      const t = i / 25;
      const x = THREE.MathUtils.lerp(-18, 22, t);
      const z = Math.sin(t * Math.PI * 2) * 8;
      const y = terrainHeight(x, z) + 0.02;
      const p = new THREE.Mesh(new THREE.CircleGeometry(2.2, 18), pathMat);
      p.rotation.x = -Math.PI / 2;
      p.position.set(x, y, z);
      p.receiveShadow = true;
      scene.add(p);
    }
  }
  scatterScene();

  function makeGrassInstanced(count = 18000) {
  const bladeGeo = new THREE.PlaneGeometry(0.06, 0.45, 1, 2);
  bladeGeo.translate(0, 0.225, 0);
  
    const bladeMat = new THREE.MeshStandardMaterial({
      color: 0x2f7a34,
      roughness: 1.0,
      metalness: 0.0,
      side: THREE.DoubleSide,
      envMapIntensity: 0.05
    });
  
    const inst = new THREE.InstancedMesh(bladeGeo, bladeMat, count);
    inst.castShadow = false;
    inst.receiveShadow = false;
  
    const dummy = new THREE.Object3D();
    const seed = new Float32Array(count * 4);
  
    for (let i = 0; i < count; i++) {
      const a = Math.random() * Math.PI * 2;
      const r = Math.sqrt(Math.random()) * (MAP_RADIUS - 2);
      const x = Math.cos(a) * r;
      const z = Math.sin(a) * r;
  
      const y = terrainHeight(x, z);
      const s = 0.6 + Math.random() * 1.0;
  
      dummy.position.set(x, y, z);
      dummy.rotation.y = Math.random() * Math.PI * 2;
      dummy.scale.set(s, s * (0.9 + Math.random() * 0.4), s);
  
      dummy.updateMatrix();
      inst.setMatrixAt(i, dummy.matrix);
  
      // store per-instance wind params (phase, strength, dir)
      seed[i*4+0] = Math.random()*10;      // phase
      seed[i*4+1] = 0.2 + Math.random()*0.6;// amp
      seed[i*4+2] = (Math.random()-0.5)*0.8;// dir
      seed[i*4+3] = dummy.rotation.y;       // yaw
    }
  
    inst.instanceMatrix.needsUpdate = true;
  
    return { inst, seed };
  }
  
  const grass = makeGrassInstanced(7000);
  scene.add(grass.inst);
  
  function updateGrassWind(time) {
    const dummy = new THREE.Object3D();
  
    for (let i = 0; i < grass.inst.count; i += 2) { // update half per frame instead of 1/6
      grass.inst.getMatrixAt(i, dummy.matrix);
      dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);
  
      const phase = grass.seed[i*4+0];
      const amp   = grass.seed[i*4+1];
      const dir   = grass.seed[i*4+2];
      const yaw   = grass.seed[i*4+3];
  
      dummy.rotation.set(
        Math.cos(time*1.0 + phase) * 0.08 * amp * dir, // x
        yaw,                                           // y (preserved)
        Math.sin(time*1.2 + phase) * 0.12 * amp         // z
      );
  
      dummy.updateMatrix();
      grass.inst.setMatrixAt(i, dummy.matrix);
    }
  
    grass.inst.instanceMatrix.needsUpdate = true;
  }
  
  // ====== Walls / props ======
  const propMat = new THREE.MeshStandardMaterial({ color: 0x1a2250, roughness: 0.75, metalness: 0.12, envMapIntensity: 0.55 });
  function pillar(x,z){
    const p = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.8,3.2,18), propMat);
    p.position.set(x,1.6,z);
    p.castShadow = true; p.receiveShadow = true;
    scene.add(p);
  }
  pillar(-10,10); pillar(10,-10); pillar(0,0);

  // ====== Player container ======
  const player = new THREE.Group();
  player.position.set(0,0,8);
  scene.add(player);
  
  // ====== Orbit camera locked to player ======
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.enablePan = false;
  controls.enableZoom = true;
  controls.zoomSpeed = 0.9;

  controls.minDistance = 2.6;
  controls.maxDistance = 7.0;
  controls.minPolarAngle = 0.15;
  controls.maxPolarAngle = Math.PI * 0.48;
  controls.rotateSpeed = 0.6;

  controls.target.copy(player.position).add(new THREE.Vector3(0, LOOK_HEIGHT, 0));
  controls.update();

  // ====== Memory spots ======
  const spots = [];
  const spotGeo = new THREE.TorusGeometry(1.0, 0.12, 16, 50);
  const glowBase = new THREE.MeshStandardMaterial({
    color: 0x7da6ff,
    emissive: 0x3b66ff,
    emissiveIntensity: 1.6,
    roughness: 0.25,
    metalness: 0.35,
    envMapIntensity: 0.8
  });

  for (const mem of MEMORIES) {
    const ring = new THREE.Mesh(spotGeo, glowBase.clone());
    ring.rotation.x = Math.PI / 2;
    ring.position.copy(mem.pos);
    ring.position.y = 0.12;
    ring.receiveShadow = true;
    ring.castShadow = false;
    scene.add(ring);

    const marker = new THREE.Mesh(
      new THREE.SphereGeometry(0.18, 18, 18),
      new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x7da6ff, emissiveIntensity: 1.0, roughness: 0.2, metalness: 0.3, envMapIntensity: 1.0 })
    );
    marker.position.copy(mem.pos);
    marker.position.y = 1.35;
    marker.castShadow = true;
    scene.add(marker);

    spots.push({ mem, ring, marker });
  }

  // ====== UI panel ======
  const panel = document.getElementById("panel");
  const panelTitle = document.getElementById("panelTitle");
  const panelText = document.getElementById("panelText");
  document.getElementById("closeBtn").onclick = () => { panel.style.display = "none"; activeSpotId = null; };

  let activeSpotId = null;
  function openMemory(mem){
    activeSpotId = mem.id;
    panelTitle.textContent = mem.title;
    panelText.textContent = mem.text;
    panel.style.display = "block";
  }

  // ====== Avatar + Animations ======
  const gltfLoader = new GLTFLoader();
  const fbxLoader  = new FBXLoader();

  let avatarRoot = null;
  let mixer = null;
  const actions = {};
  let currentAction = null;

  function playAction(name, fade=0.14){
    const next = actions[name];
    if (!next) return;
    if (currentAction === next) return;

    if (currentAction) currentAction.fadeOut(fade);
    currentAction = next;
    currentAction.reset().fadeIn(fade).play();
  }

  function loadFBX(url){
    return new Promise((resolve, reject) => {
      fbxLoader.load(url, (fbx) => {
        const clip = fbx.animations && fbx.animations[0];
        if (!clip) return reject(new Error("No animation in " + url));
        resolve(clip);
      }, undefined, reject);
    });
  }

  let jumpAnimDone = false;

  async function setupAvatarAndAnims(){
    const gltf = await new Promise((resolve, reject) => {
      gltfLoader.load(AVATAR_URL, resolve, undefined, reject);
    });

    avatarRoot = gltf.scene;
    forceMeshVisible(avatarRoot);

    avatarRoot.position.set(0,0,0);
    avatarRoot.rotation.set(0,0,0);
    avatarRoot.scale.set(1,1,1);
    player.add(avatarRoot);

    mixer = new THREE.AnimationMixer(avatarRoot);

    const [idleRaw, walkRaw, runRaw, jumpRaw, sambaRaw, rumbaRaw, salsaRaw] = await Promise.all([
      loadFBX(ANIMS.Idle),
      loadFBX(ANIMS.Walk),
      loadFBX(ANIMS.Run),
      loadFBX(ANIMS.Jump),
      loadFBX(ANIMS.Samba),
      loadFBX(ANIMS.Rumba),
      loadFBX(ANIMS.Salsa),
    ]);

    const idle = remapClipToAvatarBones(stripRootTranslation(idleRaw), avatarRoot, "Idle");
    const walk = remapClipToAvatarBones(stripRootTranslation(walkRaw), avatarRoot, "Walk");
    const run  = remapClipToAvatarBones(stripRootTranslation(runRaw),  avatarRoot, "Run");
    const jump = remapClipToAvatarBones(stripRootTranslation(jumpRaw), avatarRoot, "Jump");
    const samba = remapClipToAvatarBones(stripRootTranslation(sambaRaw), avatarRoot, "Samba");
    const rumba = remapClipToAvatarBones(stripRootTranslation(rumbaRaw), avatarRoot, "Rumba");
    const salsa = remapClipToAvatarBones(stripRootTranslation(salsaRaw), avatarRoot, "Salsa");
    
    actions.Samba = mixer.clipAction(samba);
    actions.Rumba = mixer.clipAction(rumba);
    actions.Salsa = mixer.clipAction(salsa);
    
    for (const k of ["Samba","Rumba","Salsa"]) {
      actions[k].loop = THREE.LoopOnce;
      actions[k].clampWhenFinished = true;
    }
    
    actions.Idle = mixer.clipAction(idle);
    actions.Walk = mixer.clipAction(walk);
    actions.Jump = mixer.clipAction(jump);

    mixer.addEventListener("finished", (e) => {
      if (e.action === actions.Jump) jumpAnimDone = true;
      if (danceActive && e.action === actions[danceActive]) danceActive = null;
    });
    
    if ((run.tracks?.length || 0) < MIN_TRACKS_FOR_RUN) {
      actions.Run = mixer.clipAction(walk);
      actions.Run.setEffectiveTimeScale(1.35);
    } else {
      actions.Run = mixer.clipAction(run);
      actions.Run.setEffectiveTimeScale(1.08);
    }

    actions.Walk.setEffectiveTimeScale(1.0);
    actions.Idle.setEffectiveTimeScale(1.0);

    actions.Jump.loop = THREE.LoopOnce;
    actions.Jump.clampWhenFinished = true;

    playAction("Idle", 0.0);
  }

  setupAvatarAndAnims().catch((e) => console.error("Avatar/anims failed:", e));

  // ====== Audio (procedural wind + footsteps) ======
  let audioCtx = null;
  let master = null;
  let windGain = null;

  function ensureAudio(){
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    master = audioCtx.createGain();
    master.gain.value = 0.9;
    master.connect(audioCtx.destination);

    // --- Wind: looped noise through bandpass ---
    const bufferSize = audioCtx.sampleRate * 2;
    const noiseBuf = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = noiseBuf.getChannelData(0);
    for (let i=0;i<bufferSize;i++){
      data[i] = (Math.random()*2-1) * 0.45;
    }
    const windSrc = audioCtx.createBufferSource();
    windSrc.buffer = noiseBuf;
    windSrc.loop = true;

    const bp = audioCtx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.value = 380;
    bp.Q.value = 0.8;

    const lp = audioCtx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.value = 1400;

    windGain = audioCtx.createGain();
    windGain.gain.value = 0.06; // subtle

    windSrc.connect(bp);
    bp.connect(lp);
    lp.connect(windGain);
    windGain.connect(master);
    windSrc.start();
  }

  function playFootstep(strength=1){
    if (!audioCtx) return;

    const t = audioCtx.currentTime;

    // thump
    const osc = audioCtx.createOscillator();
    osc.type = "sine";
    osc.frequency.setValueAtTime(120, t);
    osc.frequency.exponentialRampToValueAtTime(70, t + 0.08);

    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.08 * strength, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);

    // grit
    const nSize = (audioCtx.sampleRate * 0.12)|0;
    const nb = audioCtx.createBuffer(1, nSize, audioCtx.sampleRate);
    const nd = nb.getChannelData(0);
    for (let i=0;i<nSize;i++){
      nd[i] = (Math.random()*2-1) * (1 - i/nSize);
    }
    const ns = audioCtx.createBufferSource();
    ns.buffer = nb;

    const hp = audioCtx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.value = 700;

    const ng = audioCtx.createGain();
    ng.gain.setValueAtTime(0.0001, t);
    ng.gain.exponentialRampToValueAtTime(0.05 * strength, t + 0.01);
    ng.gain.exponentialRampToValueAtTime(0.0001, t + 0.09);

    osc.connect(g);
    g.connect(master);

    ns.connect(hp);
    hp.connect(ng);
    ng.connect(master);

    osc.start(t);
    osc.stop(t + 0.14);

    ns.start(t);
    ns.stop(t + 0.12);
  }

  // start audio on first user gesture
  window.addEventListener("pointerdown", async () => {
    ensureAudio();
    if (audioCtx && audioCtx.state !== "running") await audioCtx.resume();
  }, { once: true });

  // ====== Movement + Jump physics ======
  const keys = new Set();
  let jumpRequested = false;
  let danceActive = null;   // "Samba" | "Rumba" | "Salsa" | null

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    keys.add(k);
  
    if (k === "1") { danceActive = "Samba"; playAction("Samba", 0.08); }
    if (k === "2") { danceActive = "Rumba"; playAction("Rumba", 0.08); }
    if (k === "3") { danceActive = "Salsa"; playAction("Salsa", 0.08); }
  
    if (k === " " || k === "spacebar") jumpRequested = true;
  });
  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

  const clock = new THREE.Clock();
  const tmpVec = new THREE.Vector3();

  function clampToMap(pos) {
    const d = Math.hypot(pos.x, pos.z);
    if (d > MAP_RADIUS) {
      const s = MAP_RADIUS / d;
      pos.x *= s;
      pos.z *= s;
    }
  }

  let isJumping = false;
  let yVel = 0;

  function startJump() {
    if (isJumping) return;
    isJumping = true;
    jumpAnimDone = false;
    yVel = JUMP_VEL;
    playAction("Jump", 0.06);
  }

  // footsteps timer
  let stepTimer = 0;

  function updatePlayer(dt){
    if (jumpRequested && !isJumping) {
      jumpRequested = false;
      startJump();
    } else if (jumpRequested) {
      jumpRequested = false;
    }

    const isRunning = keys.has("shift");
    const speed = isRunning ? RUN_SPEED : WALK_SPEED;

    let forward = 0, right = 0;
    if (keys.has("w")) forward += 1;
    if (keys.has("s")) forward -= 1;
    if (keys.has("d")) right += 1;
    if (keys.has("a")) right -= 1;

    // Basis from camera direction
    const dirF = new THREE.Vector3();
    camera.getWorldDirection(dirF);
    dirF.y = 0;
    dirF.normalize();

    const dirR = new THREE.Vector3().crossVectors(dirF, new THREE.Vector3(0,1,0)).normalize();

    tmpVec.set(0,0,0);
    tmpVec.addScaledVector(dirF, forward);
    tmpVec.addScaledVector(dirR, right);

    const isMoving = tmpVec.lengthSq() > 0;

    // rotate toward movement
    if (isMoving) {
      const mv = tmpVec.clone().normalize();
      const targetYaw = Math.atan2(mv.x, mv.z);
      let d = targetYaw - player.rotation.y;
      d = Math.atan2(Math.sin(d), Math.cos(d));
      player.rotation.y += d * Math.min(1, dt * 10);
    }

    // horizontal move
    if (isMoving) {
      const control = isJumping ? AIR_CONTROL : 1.0;
      tmpVec.normalize().multiplyScalar(speed * control * dt);
      player.position.add(tmpVec);
      clampToMap(player.position);
    }

    if (isMoving && danceActive) {
      danceActive = null;
      // let locomotion take over immediately
      if (currentAction) currentAction.fadeOut(0.08);
    }
    
    // jump physics
    if (isJumping) {
      yVel += GRAVITY * dt;
      player.position.y += yVel * dt;

      const groundY = terrainHeight(player.position.x, player.position.z);
      
      if (player.position.y <= groundY) {
        player.position.y = groundY;
        yVel = 0;
        if (jumpAnimDone) isJumping = false;
      }
    }

    if (!isJumping) {
      player.position.y = terrainHeight(player.position.x, player.position.z);
    }
    
    if (actions.Idle) {
      if (danceActive) playAction(danceActive, 0.06);
      else if (isJumping) playAction("Jump", 0.05);
      else if (isMoving && isRunning) playAction("Run", 0.12);
      else if (isMoving) playAction("Walk", 0.14);
      else playAction("Idle", 0.18);
    }
    
    // footsteps
    if (!isJumping && isMoving) {
      const interval = isRunning ? STEP_INTERVAL_RUN : STEP_INTERVAL_WALK;
      stepTimer -= dt;
      if (stepTimer <= 0) {
        stepTimer = interval;
        // strength varies with run/walk
        const strength = isRunning ? 1.0 : 0.7;
        playFootstep(strength);
      }
    } else {
      // reset so first step happens quickly when you start moving again
      stepTimer = Math.min(stepTimer, 0.08);
    }
  }

  function updateCamera(dt){
    const target = player.position.clone();
    target.y += LOOK_HEIGHT;

    controls.target.lerp(target, 1 - Math.pow(0.001, dt));
    controls.update();
  }

  function checkMemoryTriggers(){
    let closest = null;
    let closestDist = Infinity;

    for (const s of spots) {
      const d = player.position.distanceTo(s.mem.pos);
      if (d < closestDist) { closestDist = d; closest = s; }
    }

    if (closest && closestDist <= 2.1) {
      if (activeSpotId !== closest.mem.id) openMemory(closest.mem);
    }
  }

  // initial sky/env bake
  updateSkyAndEnv(0);

  function animate(){
    requestAnimationFrame(animate);
    const dt = Math.min(clock.getDelta(), 0.033);

    updatePlayer(dt);
    updateCamera(dt);

    // sky/env + clouds
    updateSkyAndEnv(dt);
    updateClouds(dt);
    
    grassWindAccum += dt;
    if (grassWindAccum >= 1/30) {          // update wind at 30 Hz (not every frame)
      updateGrassWind(clock.elapsedTime);
      grassWindAccum = 0;
    }

    const t = clock.elapsedTime;
    for (const s of spots) {
      s.ring.rotation.z = t * 0.7;
      s.marker.position.y = 1.35 + Math.sin(t * 2.2 + s.mem.pos.x) * 0.08;
    }

    if (mixer) mixer.update(dt);

    checkMemoryTriggers();
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
